# -*- coding: utf-8 -*-
import telebot
from telebot import types      
import os
import json
from datetime import datetime, timedelta
import random
import threading
import time
from telebot.types import ReplyKeyboardMarkup, KeyboardButton, InlineKeyboardMarkup, InlineKeyboardButton
import time
import base64
import pytz

# Th√¥ng tin c·∫•u h√¨nh - FIXED: Use environment variable for security
API_TOKEN = '8276748111:AAEkjeNQSpAuiLoiDCWvR7QAdKJ0zJug1WU'
bot = telebot.TeleBot(API_TOKEN)

# File l∆∞u tr·ªØ d·ªØ li·ªáu
CHANNELS_FILE = 'channels.json'
SETTINGS_FILE = 'settings.json'
USER_FILE = 'users.txt'
user_data_file = 'userdata.json'
invited_users_file = 'invitedusers.json'
referral_history_file = 'referral_history.json'
# Ph·∫ßn l∆∞u tr·ªØ danh s√°ch codes
codes_file = 'codes.json'  # File l∆∞u tr·ªØ danh s√°ch code
used_codes_file = 'used_codes.json'  # File l∆∞u tr·ªØ danh s√°ch code ƒë√£ s·ª≠ d·ª•ng
game_link_file = 'game_link.json'  # File l∆∞u tr·ªØ link game
DROP_CODES_FILE = 'drop_codes.json'  # M√£ ri√™ng cho ƒê·∫≠p H·ªôp

# Danh s√°ch admin
admins = [7205961265,6118978649]  # Danh s√°ch ID admin

# Kh·ªüi t·∫°o bi·∫øn to√†n c·ª•c
user_data = {}
auto_approve = False  # Bi·∫øn ƒëi·ªÅu khi·ªÉn duy·ªát t·ª± ƒë·ªông
invited_users = {}
referral_history = {}  # L∆∞u tr·ªØ l·ªãch s·ª≠ ng∆∞·ªùi ƒë∆∞·ª£c m·ªùi b·ªüi ai
codes = []  # Danh s√°ch code ƒë·ªÉ ƒë·ªïi
used_codes = {}  # Danh s√°ch code ƒë√£ s·ª≠ d·ª•ng
game_link = ""  # Link game hi·ªán t·∫°i
drop_codes = []  # Danh s√°ch code ri√™ng cho ƒê·∫≠p H·ªôp

# === ƒê·∫¨P H·ªòP: Tr·∫°ng th√°i m·ªói ƒë·ª£t ph√°t code ===
current_drop = {
    'id': 0,
    'active': False,
    'start_ts': None,
    'end_ts': None,
    'claimed_users': [],
    'chat_id': None,
    'message_id': None
}
drop_window_minutes = 60  # Th·ªùi gian h·ª£p l·ªá c·ªßa m·ªói ƒë·ª£t (ph√∫t)
drop_thread_started = False
drop_lock = threading.Lock()

# NEW: Enhanced logging functions
def log_debug(message):
    """H√†m logging debug chi ti·∫øt"""
    timestamp = datetime.now().strftime("%Y-%m-%d %H:%M:%S")
    print(f"[DEBUG] {timestamp} - {message}")

def log_error(message):
    """H√†m logging l·ªói"""
    timestamp = datetime.now().strftime("%Y-%m-%d %H:%M:%S")
    print(f"[ERROR] {timestamp} - {message}")

# NEW: Subscription result class for improved error handling
class SubscriptionResult:
    """Result of subscription check"""
    def __init__(self, subscribed, error=None, retry_needed=False):
        self.subscribed = subscribed
        self.error = error
        self.retry_needed = retry_needed

# H√†m l∆∞u l·ªãch s·ª≠ gi·ªõi thi·ªáu
def save_referral_history():
    with open(referral_history_file, 'w') as file:
        json.dump(referral_history, file, indent=4)

# H√†m t·∫£i l·ªãch s·ª≠ gi·ªõi thi·ªáu
def load_referral_history():
    try:
        with open(referral_history_file, 'r') as file:
            return json.load(file)
    except (FileNotFoundError, json.JSONDecodeError):
        return {}

# H√†m l∆∞u danh s√°ch code
def save_codes():
    with open(codes_file, 'w') as file:
        json.dump(codes, file, indent=4)

# H√†m t·∫£i danh s√°ch code
def load_codes():
    try:
        with open(codes_file, 'r') as file:
            return json.load(file)
    except (FileNotFoundError, json.JSONDecodeError):
        return []

# H√†m l∆∞u/t·∫£i CODE ri√™ng cho ƒê·∫≠p H·ªôp
def save_drop_codes():
    global drop_codes
    with open(DROP_CODES_FILE, 'w') as f:
        json.dump(drop_codes, f, indent=4)

def load_drop_codes():
    try:
        with open(DROP_CODES_FILE, 'r') as f:
            return json.load(f)
    except (FileNotFoundError, json.JSONDecodeError):
        return []

# H√†m l∆∞u danh s√°ch code ƒë√£ s·ª≠ d·ª•ng
def save_used_codes():
    with open(used_codes_file, 'w') as file:
        json.dump(used_codes, file, indent=4)

# H√†m t·∫£i danh s√°ch code ƒë√£ s·ª≠ d·ª•ng
def load_used_codes():
    try:
        with open(used_codes_file, 'r') as file:
            return json.load(file)
    except (FileNotFoundError, json.JSONDecodeError):
        return {}

# H√†m l∆∞u link game
def save_game_link(link):
    with open(game_link_file, 'w') as file:
        json.dump({'game_link': link}, file, indent=4)

# H√†m t·∫£i link game
def load_game_link():
    try:
        with open(game_link_file, 'r') as file:
            data = json.load(file)
            return data.get('game_link', '')
    except (FileNotFoundError, json.JSONDecodeError):
        return ''

# H√†m t·∫£i c√†i ƒë·∫∑t t·ª´ file
def load_settings():
    try:
        with open(SETTINGS_FILE, 'r') as file:
            return json.load(file)
    except (FileNotFoundError, json.JSONDecodeError):
        # C√†i ƒë·∫∑t m·∫∑c ƒë·ªãnh n·∫øu file kh√¥ng t·ªìn t·∫°i
        default_settings = {
            'referral_bonus': 1500,  # Th∆∞·ªüng khi gi·ªõi thi·ªáu (VNƒê)
            'min_withdraw': 15000,  # S·ªë ti·ªÅn r√∫t t·ªëi thi·ªÉu (VNƒê)
            'announcement_image': '' # Add default image
        }
        save_settings(default_settings)
        return default_settings

# H√†m l∆∞u c√†i ƒë·∫∑t v√†o file
def save_settings(settings):
    with open(SETTINGS_FILE, 'w') as file:
        json.dump(settings, file, indent=4)

# ƒê·∫¨P H·ªòP: C·∫•u h√¨nh m·ªü r·ªông
def get_drop_settings():
    settings = load_settings()
    # M·∫∑c ƒë·ªãnh n·∫øu ch∆∞a c√≥ c·∫•u h√¨nh
    if 'drop' not in settings:
        settings['drop'] = {
            'enabled': True,
            'image_url': '',  # ·∫¢nh th√¥ng b√°o, c√≥ th·ªÉ l√† URL http(s)
            'image_file_id': '',  # ·∫¢nh do admin upload (∆∞u ti√™n d√πng)
            'title': 'üéÅ ƒê·∫≠p H·ªôp',
            'button_text': 'üéÅ ƒê·∫≠p H·ªôp',
            'window_minutes': 15,
            'times': [],  # Hai th·ªùi ƒëi·ªÉm c·ªë ƒë·ªãnh HH:MM
            'cooldown_seconds': 0, # kho·∫£ng ƒë·ªám t·ªëi thi·ªÉu gi·ªØa c√°c ƒë·ª£t
            'target_chat_id': None,  # Chat ID ƒë·ªÉ g·ª≠i th√¥ng b√°o (None = g·ª≠i cho t·∫•t c·∫£ user)
            'timezone': 'Asia/Ho_Chi_Minh'  # M√∫i gi·ªù ƒë·ªÉ ch·∫°y scheduler
        }
        save_settings(settings)
    # Backward compatibility: if 'hours' exists, convert to 'times'
    drop = settings['drop']
    if 'hours' in drop and 'times' not in drop:
        hrs = drop.get('hours', [9, 21])
        drop['times'] = [f"{int(hrs[0]):02d}:00", f"{int(hrs[1]):02d}:00"]
        drop.pop('hours', None)
        save_settings(settings)
    return drop

# FIXED: Improved load_channels function

def load_channels():
    try:
        # N·∫øu file ch∆∞a t·ªìn t·∫°i ‚Üí t·∫°o file r·ªóng
        if not os.path.exists(CHANNELS_FILE):
            with open(CHANNELS_FILE, 'w', encoding='utf-8') as f:
                json.dump([], f, ensure_ascii=False, indent=2)
            log_debug("Created empty channels.json file.")
            return []

        # ƒê·ªçc d·ªØ li·ªáu t·ª´ file
        with open(CHANNELS_FILE, 'r', encoding='utf-8') as f:
            try:
                data = json.load(f)
            except json.JSONDecodeError:
                log_error("channels.json b·ªã l·ªói ƒë·ªãnh d·∫°ng ‚Üí reset file.")
                data = []
                save_channels(data)

        log_debug(f"Raw channels data loaded: {data}")

        cleaned = []
        for ch in data:
            if isinstance(ch, dict):
                username = str(ch.get('username', '')).lstrip('@').strip()
                title = str(ch.get('title', username)).strip()
                if username:
                    cleaned.append({'username': username, 'title': title})
            else:
                username = str(ch).lstrip('@').strip()
                if username:
                    cleaned.append({'username': username, 'title': username})

        log_debug(f"Cleaned channels: {cleaned}")
        return cleaned

    except Exception as e:
        log_error(f"load_channels error: {e}")
        return []


def save_channels(channels):
    try:
        with open('channels.json', 'w', encoding='utf-8') as f:
            json.dump(channels, f, indent=2, ensure_ascii=False)
        log_debug(f"Channels saved: {channels}")
    except Exception as e:
        log_error(f"save_channels error: {e}")

# FIXED: Improved check_bot_admin_status
def check_bot_admin_status():
    channels = load_channels()
    status_report = {}
    bot_id = bot.get_me().id

    for channel in channels:
        try:
            if isinstance(channel, dict):
                channel_key = channel.get('username', 'unknown_channel')
            else:
                channel_key = str(channel).lstrip('@')

            # Try different formats (removed invalid -100 prefix for usernames)
            chat_identifiers = [f'@{channel_key}', channel_key]
            
            for chat_id in chat_identifiers:
                try:
                    bot_info = bot.get_chat_member(chat_id, bot_id)
                    if bot_info.status in ['administrator', 'creator']:
                        status_report[channel_key] = True
                        log_debug(f"Bot is admin in {chat_id}")
                        break
                    else:
                        status_report[channel_key] = False
                        log_debug(f"Bot is not admin in {chat_id}, status: {bot_info.status}")
                except Exception as inner_e:
                    continue
            else:
                status_report[channel_key] = False
                log_error(f"Could not check bot status in {channel_key}")

        except Exception as e:
            log_error(f"Error checking bot status for {channel}: {e}")
            status_report[channel_key] = False

    return status_report

# H√†m ƒë·ªÉ g·ª≠i tin nh·∫Øn ri√™ng cho ng∆∞·ªùi d√πng
def send_private_message(user_id, message):
    try:
        bot.send_message(user_id, message)
        log_debug(f"Sent private message to user {user_id}")
    except telebot.apihelper.ApiException as e:
        log_error(f"Error sending private message to {user_id}: {e}")

# NEW: Function to verify bot access to channels
def verify_bot_access(chat_id):
    """Verify if bot has access to a channel/group"""
    try:
        bot_id = bot.get_me().id
        
        # FIXED: Better handling of different ID formats
        chat_identifiers = []
        
        # Handle numeric IDs (including negative ones like -100...)
        if chat_id.lstrip('-').isdigit():
            chat_identifiers.append(int(chat_id))
            chat_identifiers.append(chat_id)  # Keep as string too
        else:
            # Handle username format
            clean_id = chat_id.lstrip('@')
            chat_identifiers.append(f'@{clean_id}')
            chat_identifiers.append(clean_id)
        
        for identifier in chat_identifiers:
            try:
                # Try to get bot's membership status
                bot_member = bot.get_chat_member(identifier, bot_id)
                log_debug(f"Bot access to {identifier}: {bot_member.status}")
                
                # Bot needs to be at least a member to check other members
                if bot_member.status in ['member', 'administrator', 'creator']:
                    return {'has_access': True, 'status': bot_member.status}
                else:
                    return {'has_access': False, 'error': f'Bot status: {bot_member.status}'}
                    
            except telebot.apihelper.ApiException as e:
                error_desc = str(e).lower()
                if "chat not found" in error_desc:
                    continue  # Try next identifier
                log_debug(f"Bot access check failed for {identifier}: {e}")
                continue
        
        return {'has_access': False, 'error': 'Could not verify bot access with any identifier'}
        
    except Exception as e:
        log_error(f"Error verifying bot access to {chat_id}: {e}")
        return {'has_access': False, 'error': str(e)}

# NEW: Enhanced subscription checking with retry mechanism
def check_subscription_with_retry(user_id, max_retries=3):
    """Check subscription with intelligent retry mechanism"""
    for attempt in range(max_retries):
        try:
            result = check_subscription(user_id)
            if isinstance(result, SubscriptionResult):
                if not result.retry_needed:
                    return result.subscribed
                elif attempt == max_retries - 1:
                    log_error(f"Max retries reached for user {user_id}, returning False")
                    return False
                else:
                    sleep_time = 2 ** attempt  # Exponential backoff
                    log_debug(f"Retrying subscription check for user {user_id} in {sleep_time}s")
                    time.sleep(sleep_time)
            else:
                return result
        except Exception as e:
            log_error(f"Subscription check attempt {attempt + 1} failed for user {user_id}: {e}")
            if attempt < max_retries - 1:
                time.sleep(2 ** attempt)  # Exponential backoff
    return False

# FIXED: Completely rewritten check_subscription function
def check_subscription(user_id):
    """Enhanced subscription checking with improved error handling"""
    if user_id in admins:
        log_debug(f"User {user_id} is admin, subscription check passed")
        return True

    channels = load_channels()
    log_debug(f"Checking subscription for user {user_id}")
    log_debug(f"Channels to check: {channels}")
    
    if not channels:
        log_debug("No channels configured, allowing access")
        return True

    for channel in channels:
        try:
            # Handle both dict and string formats
            if isinstance(channel, dict):
                chat_id = channel.get("username", "").strip()
                title = channel.get("title", chat_id)
            else:
                chat_id = str(channel).strip()
                title = chat_id

            # Clean up chat_id
            chat_id = chat_id.lstrip('@')
            
            if not chat_id:
                log_debug(f"Empty chat_id for channel {channel}, skipping")
                continue

            log_debug(f"Checking user {user_id} in channel: {chat_id}")
            
            # First verify bot has access to the channel
            bot_access_result = verify_bot_access(chat_id)
            if not bot_access_result['has_access']:
                log_error(f"Bot lacks access to {chat_id}: {bot_access_result['error']}")
                # Return retry-needed result for bot permission issues
                return SubscriptionResult(False, bot_access_result['error'], retry_needed=True)
            
            # FIXED: Better handling of different ID formats
            chat_identifiers = []
            
            # Handle numeric IDs (including negative ones like -100...)
            if chat_id.lstrip('-').isdigit():
                chat_identifiers.append(int(chat_id))
                chat_identifiers.append(chat_id)  # Keep as string too
            else:
                # Handle username format
                chat_identifiers.append(f'@{chat_id}')
                chat_identifiers.append(chat_id)
            
            member = None
            last_error = None
            
            for identifier in chat_identifiers:
                try:
                    member = bot.get_chat_member(identifier, user_id)
                    log_debug(f"Successfully got member info for {identifier}")
                    break
                except telebot.apihelper.ApiException as api_e:
                    last_error = api_e
                    error_desc = str(api_e).lower()
                    log_debug(f"Failed to get member info for {identifier}: {api_e}")
                    
                    # Check if this is a transient error that should be retried
                    if any(x in error_desc for x in ['timeout', 'too many requests', 'internal server error', '429', '5']):
                        log_debug(f"Transient error detected for {identifier}")
                        return SubscriptionResult(False, str(api_e), retry_needed=True)
                    continue
            
            if member is None:
                error_desc = str(last_error).lower() if last_error else "unknown error"
                
                # Categorize the error
                if "chat not found" in error_desc:
                    log_error(f"Channel {chat_id} not found - skipping")
                    continue  # Skip non-existent channels
                elif "user not found" in error_desc:
                    log_error(f"User {user_id} not found")
                    return False  # Definitive: user doesn't exist
                elif "bot was blocked" in error_desc:
                    log_error(f"Bot was blocked by user {user_id}")
                    return False  # Definitive: user blocked bot
                elif any(x in error_desc for x in ['not enough rights', 'forbidden', 'bot is not a member']):
                    log_error(f"Bot permission issue for {chat_id}: {last_error}")
                    return SubscriptionResult(False, str(last_error), retry_needed=True)
                else:
                    log_error(f"Could not get member info for user {user_id} in {chat_id}: {last_error}")
                    return SubscriptionResult(False, str(last_error), retry_needed=True)
            
            log_debug(f"User {user_id} status in {chat_id}: {member.status}")
            
            # Consider 'restricted' as subscribed (they're in the channel but limited)
            if member.status in ['member', 'administrator', 'creator', 'restricted']:
                log_debug(f"User {user_id} is subscribed to {chat_id} (status: {member.status})")
                continue
            elif member.status in ['left', 'kicked']:
                log_debug(f"User {user_id} not subscribed to {chat_id} (status: {member.status})")
                return False  # Definitive: user left or was kicked
            else:
                log_debug(f"Unknown status {member.status} for user {user_id} in {chat_id}")
                return SubscriptionResult(False, f"Unknown status: {member.status}", retry_needed=True)
                
        except telebot.apihelper.ApiException as e:
            error_desc = str(e).lower()
            log_error(f"API Error for channel {chat_id}: {e}")
            
            # Handle different types of API errors
            if "chat not found" in error_desc:
                log_error(f"Channel {chat_id} not found - skipping")
                continue
            elif "user not found" in error_desc:
                return False  # Definitive
            elif "bot was blocked" in error_desc:
                return False  # Definitive
            elif any(x in error_desc for x in ['timeout', 'too many requests', 'internal server error', '429', '5']):
                return SubscriptionResult(False, str(e), retry_needed=True)
            else:
                return SubscriptionResult(False, str(e), retry_needed=True)
                
        except Exception as exc:
            log_error(f"Unexpected error checking {chat_id}: {exc}")
            return SubscriptionResult(False, str(exc), retry_needed=True)
    
    log_debug(f"User {user_id} subscribed to all required channels")
    return True

def load_data(file_path):
    try:
        with open(file_path, 'r') as file:
            return json.load(file)
    except (FileNotFoundError, json.JSONDecodeError):
        return {}

def add_user(user_id):
    if not os.path.exists(USER_FILE):
        with open(USER_FILE, 'w') as file:
            file.write('')

    with open(USER_FILE, 'r') as file:
        users = file.read().splitlines()

    if str(user_id) not in users:
        with open(USER_FILE, 'a') as file:
            file.write(f"{user_id}\n")

def count_users():
    if not os.path.exists(USER_FILE):
        return 0
    with open(USER_FILE, 'r') as file:
        users = file.read().splitlines()
    return len(users)

# H√†m l∆∞u d·ªØ li·ªáu
def save_data(file_path, data):
    with open(file_path, 'w') as file:
        json.dump(data, file, indent=4)

# H√†m l·∫•y s·ªë d∆∞ c·ªßa ng∆∞·ªùi d√πng
def get_balance(user_id):
    user_id_str = str(user_id)
    if user_id_str in user_data:
        if 'balance' not in user_data[user_id_str]:
            user_data[user_id_str]['balance'] = 0
            save_data(user_data_file, user_data)
        return user_data[user_id_str]['balance']
    else:
        initialize_user(user_id)
        return 0

# H√†m kh·ªüi t·∫°o ng∆∞·ªùi d√πng
def initialize_user(user_id):
    user_id_str = str(user_id)
    if user_id_str not in user_data:
        user_data[user_id_str] = {
            'balance': 0, 
            'referrals': [],
            'withdrawals': 0,
            'invited_count': 0
        }
        save_data(user_data_file, user_data)

# H√†m c·∫≠p nh·∫≠t s·ªë d∆∞ c·ªßa ng∆∞·ªùi d√πng
def update_user_balance(user_id, amount):
    user_id_str = str(user_id)
    if user_id_str in user_data:
        if 'balance' not in user_data[user_id_str]:
            user_data[user_id_str]['balance'] = 0
        user_data[user_id_str]['balance'] += amount
    else:
        user_data[user_id_str] = {
            'balance': amount, 
            'referrals': [],
            'withdrawals': 0,
            'invited_count': 0
        }
    save_data(user_data_file, user_data)

def save_user_data(user_data):
    with open(user_data_file, 'w') as file:
        json.dump(user_data, file, indent=4)

# H√†m l·∫•y danh s√°ch ng∆∞·ªùi ƒë∆∞·ª£c m·ªùi b·ªüi m·ªôt ng∆∞·ªùi d√πng
def get_referred_users(user_id):
    referred_users = []
    user_id_str = str(user_id)

    # Ki·ªÉm tra trong user_data (∆∞u ti√™n)
    if user_id_str in user_data and 'referrals' in user_data[user_id_str]:
        referred_users = user_data[user_id_str]['referrals'].copy()

    # Ki·ªÉm tra trong l·ªãch s·ª≠ gi·ªõi thi·ªáu
    if user_id_str in referral_history:
        for ref_user in referral_history[user_id_str]:
            if ref_user not in referred_users:
                referred_users.append(ref_user)

    # Ki·ªÉm tra trong danh s√°ch ƒëang ch·ªù x·ª≠ l√Ω
    for invited_id, referrer_id in invited_users.items():
        if referrer_id == user_id_str and invited_id not in referred_users:
            referred_users.append(invited_id)

    return referred_users

# H√†m x·ª≠ l√Ω khi ng∆∞·ªùi d√πng s·ª≠ d·ª•ng m√£ gi·ªõi thi·ªáu
def process_referral(user_id, referrer_id):
    user_id_str = str(user_id)
    referrer_id_str = str(referrer_id)
    
    # Kh·ªüi t·∫°o ng∆∞·ªùi d√πng m·ªõi n·∫øu ch∆∞a t·ªìn t·∫°i
    if user_id_str not in user_data:
        initialize_user(user_id)
    
    # Kh·ªüi t·∫°o ng∆∞·ªùi gi·ªõi thi·ªáu n·∫øu ch∆∞a t·ªìn t·∫°i
    if referrer_id_str not in user_data:
        initialize_user(referrer_id)
    
    # ƒê·∫£m b·∫£o c√≥ kh√≥a 'referrals' cho ng∆∞·ªùi gi·ªõi thi·ªáu
    if 'referrals' not in user_data[referrer_id_str]:
        user_data[referrer_id_str]['referrals'] = []
    
    # Th√™m ng∆∞·ªùi ƒë∆∞·ª£c gi·ªõi thi·ªáu v√†o danh s√°ch
    if user_id_str not in user_data[referrer_id_str]['referrals']:
        user_data[referrer_id_str]['referrals'].append(user_id_str)
    
    # C·∫≠p nh·∫≠t l·ªãch s·ª≠ gi·ªõi thi·ªáu
    if referrer_id_str not in referral_history:
        referral_history[referrer_id_str] = []
    if user_id_str not in referral_history[referrer_id_str]:
        referral_history[referrer_id_str].append(user_id_str)
    
    # C·ªông ti·ªÅn th∆∞·ªüng cho ng∆∞·ªùi gi·ªõi thi·ªáu
    settings = load_settings()
    referral_bonus = settings.get('referral_bonus', 1500)
    update_user_balance(referrer_id, referral_bonus)
    
    # TƒÉng counter s·ªë l∆∞·ª£t m·ªùi
    if 'invited_count' not in user_data[referrer_id_str]:
        user_data[referrer_id_str]['invited_count'] = 0
    user_data[referrer_id_str]['invited_count'] += 1
    
    # L∆∞u d·ªØ li·ªáu
    save_data(user_data_file, user_data)
    save_referral_history()

# H√†m l·∫•y code ng·∫´u nhi√™n t·ª´ danh s√°ch code c√≥ s·∫µn
def get_random_code():
    global codes
    if not codes:
        return None
    code = random.choice(codes)
    try:
        codes.remove(code)
    except ValueError:
        return None
    save_codes()
    return code

# ƒê·∫¨P H·ªòP: l·∫•y code ri√™ng cho ƒë·∫≠p h·ªôp
def get_drop_code():
    global drop_codes
    if not drop_codes:
        return None
    # Gi·ªõi h·∫°n ch·ªâ 5 code m·ªói ƒë·ª£t
    if len(current_drop.get('claimed_users', [])) >= 5:
        return None
    code = random.choice(drop_codes)
    try:
        drop_codes.remove(code)
    except ValueError:
        return None
    with open(DROP_CODES_FILE, 'w') as f:
        json.dump(drop_codes, f, indent=4)
    return code

# ƒê·∫¨P H·ªòP: T·∫°o ID ƒë·ª£t v√† kh·ªüi t·∫°o ƒë·ª£t m·ªõi
def start_new_drop():
    global current_drop
    drop_conf = get_drop_settings()
    window = int(drop_conf.get('window_minutes', drop_window_minutes))
    now = datetime.now()
    with drop_lock:
        current_drop = {
            'id': int(time.time()),
            'active': True,
            'start_ts': now.timestamp(),
            'end_ts': (now + timedelta(minutes=window)).timestamp(),
            'claimed_users': [],
            'chat_id': None,
            'message_id': None
        }
    return current_drop

def is_drop_active():
    with drop_lock:
        if not current_drop.get('active'):
            return False
        return time.time() <= current_drop.get('end_ts', 0)

def end_current_drop():
    global current_drop
    with drop_lock:
        current_drop['active'] = False
        current_drop['end_ts'] = time.time()

# T·∫£i d·ªØ li·ªáu ng∆∞·ªùi d√πng
user_data = load_data(user_data_file)
invited_users = load_data(invited_users_file)

# Load initial data
codes = load_codes()
used_codes = load_used_codes()
referral_history = load_referral_history()
game_link = load_game_link()
drop_codes = load_drop_codes()

# NEW: Function to check bot permissions in all channels
def check_bot_permissions():
    """Check bot permissions in all configured channels"""
    channels = load_channels()
    log_debug("=== CHECKING BOT PERMISSIONS ===")
    
    bot_info = bot.get_me()
    bot_id = bot_info.id
    
    permissions_report = []
    
    for channel in channels:
        try:
            if isinstance(channel, dict):
                chat_id = channel.get("username", "").lstrip('@')
                title = channel.get("title", chat_id)
            else:
                chat_id = str(channel).lstrip('@')
                title = chat_id
                
            if not chat_id:
                continue
            
            # FIXED: Better handling of different ID formats
            chat_identifiers = []
            
            # Handle numeric IDs (including negative ones like -100...)
            if chat_id.lstrip('-').isdigit():
                chat_identifiers.append(int(chat_id))
                chat_identifiers.append(chat_id)  # Keep as string too
            else:
                # Handle username format
                chat_identifiers.append(f'@{chat_id}')
                chat_identifiers.append(chat_id)
            
            for identifier in chat_identifiers:
                try:
                    # Check bot membership
                    bot_member = bot.get_chat_member(identifier, bot_id)
                    
                    # Get chat info
                    chat_info = bot.get_chat(identifier)
                    
                    status_info = {
                        'channel': chat_id,
                        'title': title,
                        'chat_type': chat_info.type,
                        'bot_status': bot_member.status,
                        'chat_title': getattr(chat_info, 'title', 'N/A'),
                        'success': True
                    }
                    permissions_report.append(status_info)
                    
                    log_debug(f"Bot in {identifier}: {bot_member.status}")
                    log_debug(f"   - Type: {chat_info.type}")
                    log_debug(f"   - Title: {getattr(chat_info, 'title', 'N/A')}")
                    break
                    
                except Exception as inner_e:
                    continue
            else:
                # If all formats failed
                error_info = {
                    'channel': chat_id,
                    'title': title,
                    'error': 'Could not access channel',
                    'success': False
                }
                permissions_report.append(error_info)
                log_error(f"Cannot access {chat_id}")
                
        except Exception as e:
            error_info = {
                'channel': getattr(channel, 'username', str(channel)),
                'error': str(e),
                'success': False
            }
            permissions_report.append(error_info)
            log_error(f"Error checking {channel}: {e}")
    
    return permissions_report

# ===== ƒê·∫¨P H·ªòP: G·ª≠i th√¥ng b√°o ƒë·ª£t m·ªõi =====
def broadcast_drop_announcement(chat_id):
    drop_conf = get_drop_settings()
    window = int(drop_conf.get('window_minutes', 15))
    title = drop_conf.get('title', 'üéÅ ƒê·∫≠p H·ªôp')
    image_url = drop_conf.get('image_url', '')
    image_file_id = drop_conf.get('image_file_id', '')
    button_text = drop_conf.get('button_text', 'üéÅ ƒê·∫≠p H·ªôp')

    started = start_new_drop()
    end_time = datetime.fromtimestamp(started['end_ts']).strftime('%H:%M')

    caption = (
        f"{title}\n\n"
        f"üéÅ Code h√¥m nay ƒë·∫øn r·ªìi mau d·ª±t code thoi\n"
        f"‚õî ƒê·∫≠p h·ªôp ch·ªâ c√≥ 5p , sau 5p h·ªôp s·∫Ω bi·∫øn m·∫•t\n\n"
        f"üîî ƒê·ª´ng qu√™n b·∫≠t chu√¥ng th√¥ng b√°o nh√©!\n"
        f"üéÆ M·ªùi b·∫°n choi ngay \n"
    )

    markup = InlineKeyboardMarkup()
    markup.add(InlineKeyboardButton(button_text, callback_data=f"dap_hop:{started['id']}"))
    gl = load_game_link()
    if gl:
        markup.add(InlineKeyboardButton("üåê Link Game", url=gl))

    try:
        sent = None
        if image_file_id:
            sent = bot.send_photo(chat_id, image_file_id, caption=caption, reply_markup=markup)
        elif image_url:
            sent = bot.send_photo(chat_id, image_url, caption=caption, reply_markup=markup)
        else:
            sent = bot.send_message(chat_id, caption, reply_markup=markup)
        with drop_lock:
            current_drop['chat_id'] = chat_id
            current_drop['message_id'] = getattr(sent, 'message_id', None)
    except Exception as e:
        log_error(f"Broadcast drop failed: {e}")

# G·ª≠i th√¥ng b√°o ƒê·∫≠p H·ªôp cho t·∫•t c·∫£ user
def send_to_all_users():
    try:
        # ƒê·ªçc danh s√°ch user t·ª´ file
        if not os.path.exists(USER_FILE):
            return
        
        with open(USER_FILE, 'r') as file:
            users = file.read().splitlines()
        
        sent_count = 0
        for user_id in users:
            if user_id.strip():
                try:
                    broadcast_drop_announcement(int(user_id))
                    sent_count += 1
                    time.sleep(0.1)  # Tr√°nh spam
                except Exception as e:
                    log_error(f"Failed to send to user {user_id}: {e}")
                    continue
        
        log_debug(f"Sent drop announcement to {sent_count} users")
    except Exception as e:
        log_error(f"send_to_all_users failed: {e}")

# Th√¥ng b√°o h·∫øt code cho t·∫•t c·∫£ user
def announce_out_of_codes():
    try:
        conf = get_drop_settings()
        gl = load_game_link()
        
        msg = (
            "üéÅ ƒê·∫≠p H·ªôp\n\n"
            "üòî R·∫•t ti·∫øc, b·∫°n ch∆∞a tr√∫ng CODE l·∫ßn n√†y.\n"
            "‚ú® Ch√∫c b·∫°n may m·∫Øn l·∫ßn sau üéÅ\n\n"
            "üîî ƒê·ª´ng qu√™n b·∫≠t chu√¥ng th√¥ng b√°o nh√©!\n"
            "üéÆ Ch∆°i ngay kh√¥ng c·∫ßn code"
        )

        markup = InlineKeyboardMarkup()
        if gl:
            markup.add(InlineKeyboardButton("üåê Link Game", url=gl))
        
        # G·ª≠i cho t·∫•t c·∫£ user
        if not os.path.exists(USER_FILE):
            return
        
        with open(USER_FILE, 'r') as file:
            users = file.read().splitlines()
        
        sent_count = 0
        for user_id in users:
            if user_id.strip():
                try:
                    bot.send_message(int(user_id), msg, reply_markup=markup)
                    sent_count += 1
                    time.sleep(0.1)  # tr√°nh spam
                except Exception as e:
                    log_error(f"Failed to send out-of-codes to user {user_id}: {e}")
                    continue
        
        log_debug(f"Sent out-of-codes announcement to {sent_count} users")
        announce_out_of_codes_to_chat()
                    
    except Exception as e:
        log_error(f"announce_out_of_codes failed: {e}")

# X√≥a ho√†n to√†n tin nh·∫Øn ƒê·∫≠p H·ªôp v√† n√∫t sau th·ªùi gian quy ƒë·ªãnh
def remove_drop_image_and_button():
    try:
        with drop_lock:
            chat_id = current_drop.get('chat_id')
            msg_id = current_drop.get('message_id')
        
        if chat_id and msg_id:
            try:
                # Th·ª≠ x√≥a h·∫≥n tin nh·∫Øn (bao g·ªìm ·∫£nh/n√∫t)
                bot.delete_message(chat_id, msg_id)
                log_debug("Deleted drop message after timeout")
                with drop_lock:
                    current_drop['message_id'] = None
            except Exception as delete_err:
                log_error(f"Failed to delete drop message, fallback to edit: {delete_err}")
                try:
                    # Fallback: g·ª° n√∫t v√† thay n·ªôi dung
                    bot.edit_message_reply_markup(chat_id, msg_id, reply_markup=None)
                    try:
                        bot.edit_message_caption(chat_id, msg_id, caption="üéÅ ƒê·∫≠p H·ªôp ƒë√£ k·∫øt th√∫c.", parse_mode=None)
                    except Exception:
                        bot.edit_message_text("üéÅ ƒê·∫≠p H·ªôp ƒë√£ k·∫øt th√∫c.", chat_id, msg_id)
                except Exception as e:
                    log_error(f"Failed to fallback edit drop message: {e}")
    except Exception as e:
        log_error(f"remove_drop_image_and_button failed: {e}")

# Th√¥ng b√°o h·∫øt code l√™n chat ch√≠nh
def announce_out_of_codes_to_chat():
    try:
        with drop_lock:
            chat_id = current_drop.get('chat_id')
            msg_id = current_drop.get('message_id')
        
        if chat_id and msg_id:
            try:
                # G·ª° n√∫t
                bot.edit_message_reply_markup(chat_id, msg_id, reply_markup=None)
                # Thay ·∫£nh b·∫±ng text ƒë∆°n gi·∫£n
                try:
                    bot.edit_message_caption(chat_id, msg_id, caption="üéÅ ƒê·∫≠p H·ªôp: ƒê√É H·∫æT CODE", parse_mode=None)
                except Exception:
                    # N·∫øu kh√¥ng ph·∫£i ·∫£nh, thay n·ªôi dung tin nh·∫Øn
                    bot.edit_message_text("üéÅ ƒê·∫≠p H·ªôp: ƒê√É H·∫æT CODE", chat_id, msg_id)
            except Exception as e:
                log_error(f"Failed to update out-of-codes message: {e}")
    except Exception as e:
        log_error(f"announce_out_of_codes_to_chat failed: {e}")

# T·ª± ƒë·ªông x√≥a ·∫£nh v√† n√∫t sau 5 ph√∫t
def auto_remove_drop_after_5min():
    try:
        with drop_lock:
            if not current_drop.get('active'):
                return
            start_ts = current_drop.get('start_ts')
            if not start_ts:
                return
        
        # Ki·ªÉm tra ƒë√£ qua 5 ph√∫t ch∆∞a
        current_time = time.time()
        if current_time - start_ts >= 300:  # 5 ph√∫t = 300 gi√¢y
            remove_drop_image_and_button()
            log_debug("Auto removed drop image/button after 5 minutes")
    except Exception as e:
        log_error(f"auto_remove_drop_after_5min failed: {e}")

# G·ª≠i tin nh·∫Øn h·∫øt code cho user c·ª• th·ªÉ
def send_out_of_codes_to_user(user_id):
    try:
        gl = load_game_link()
        
        msg = (
    "üéÅ ƒê·∫≠p H·ªôp\n\n"
    "üòî R·∫•t ti·∫øc, b·∫°n ch∆∞a tr√∫ng CODE l·∫ßn n√†y.\n"
    "‚ú® Ch√∫c b·∫°n may m·∫Øn l·∫ßn sau üéÅ\n\n"
    "üîî ƒê·ª´ng qu√™n b·∫≠t chu√¥ng th√¥ng b√°o nh√©!\n"
    "üéÆ Ch∆°i ngay kh√¥ng c·∫ßn code"
)
        
        markup = InlineKeyboardMarkup()
        if gl:
            markup.add(InlineKeyboardButton("üåê Link Game", url=gl))
        
        bot.send_message(user_id, msg, reply_markup=markup)
        log_debug(f"Sent out-of-codes message to user {user_id}")
        
    except Exception as e:
        log_error(f"send_out_of_codes_to_user failed: {e}")

@bot.callback_query_handler(func=lambda c: c.data and c.data.startswith('dap_hop:'))
def handle_dap_hop_callback(call):
    try:
        parts = call.data.split(':', 1)
        drop_id = int(parts[1]) if len(parts) > 1 else 0
    except Exception:
        drop_id = 0

    # Kh√¥ng x√≥a ngay, s·∫Ω t·ª± ƒë·ªông x√≥a sau 5 ph√∫t

    # Ki·ªÉm tra ƒë·ª£t c√≤n hi·ªáu l·ª±c
    if not is_drop_active() or drop_id != current_drop.get('id'):
        bot.answer_callback_query(call.id, text='ƒê·ª£t ƒë√£ k·∫øt th√∫c ho·∫∑c kh√¥ng h·ª£p l·ªá.', show_alert=True)
        return

    user_id = call.from_user.id


    # Y√™u c·∫ßu theo d√µi k√™nh (n·∫øu c√≥)
    if not check_subscription_with_retry(user_id):
        bot.answer_callback_query(call.id, text='Vui l√≤ng tham gia c√°c k√™nh b·∫Øt bu·ªôc tr∆∞·ªõc!', show_alert=True)
        return

    # G√°n code theo nguy√™n t·∫Øc ai nhanh ng∆∞·ªùi ƒë∆∞·ª£c
    with drop_lock:
        if user_id in current_drop['claimed_users']:
            bot.answer_callback_query(call.id, text='B·∫°n ƒë√£ nh·∫≠n r·ªìi!', show_alert=True)
            return
        code = get_drop_code()
        if code is None:
            # H·∫æT CODE - Ch·ªâ g·ª≠i tin nh·∫Øn ri√™ng cho user n√†y
            end_current_drop()
            send_out_of_codes_to_user(user_id)
            bot.answer_callback_query(call.id, text='ƒê√£ h·∫øt CODE cho ƒë·ª£t n√†y!', show_alert=True)
            return
        # L∆∞u used_codes
        used_codes[str(user_id)] = {
            'code': code,
            'time': datetime.now().isoformat()
        }
        save_used_codes()
        current_drop['claimed_users'].append(user_id)

    # G·ª≠i code ri√™ng cho ng∆∞·ªùi d√πng
    try:
        bot.answer_callback_query(call.id, text='Nh·∫≠n CODE th√†nh c√¥ng! Ki·ªÉm tra tin nh·∫Øn.', show_alert=False)
        bot.send_message(user_id, f"üéÅ CODE c·ªßa b·∫°n: <b>{code}</b>", parse_mode='HTML')
    except Exception as e:
        log_error(f"Send code to user failed: {e}")


# Menu cho admin
def admin_menu(message):
    if message.from_user.id in admins:
        markup = types.ReplyKeyboardMarkup(row_width=2, resize_keyboard=True)
        markup.add(types.KeyboardButton('üìã Qu·∫£n l√Ω nh√≥m'),
                   types.KeyboardButton('‚öôÔ∏è C√†i ƒë·∫∑t h·ªá th·ªëng'))
        markup.add(types.KeyboardButton('üìä Th·ªëng k√™'),
                   types.KeyboardButton('üì¢ Th√¥ng b√°o to√†n h·ªá th·ªëng'))
        markup.add(types.KeyboardButton('üí∞ C·ªông ti·ªÅn'),
                   types.KeyboardButton('üéÅ Qu·∫£n l√Ω CODE'))
        markup.add(types.KeyboardButton('üéÆ Qu·∫£n l√Ω Link Game'),
                   types.KeyboardButton('üñº Thay ƒë·ªïi ·∫£nh th√¥ng b√°o'))
        markup.add(types.KeyboardButton('üéÅ C·∫•u h√¨nh ƒê·∫≠p H·ªôp'))
        markup.add(types.KeyboardButton('üîô Quay l·∫°i menu ch√≠nh'))

        bot.send_message(
            message.chat.id,
            "üì± <b>Menu qu·∫£n tr·ªã vi√™n</b>\n\nCh·ªçn ch·ª©c nƒÉng b·∫°n mu·ªën s·ª≠ d·ª•ng:",
            reply_markup=markup,
            parse_mode='HTML')
    else:
        bot.send_message(message.chat.id,
                         "‚ùå B·∫°n kh√¥ng c√≥ quy·ªÅn truy c·∫≠p menu n√†y!")


@bot.message_handler(func=lambda message: message.text == "üéÅ C·∫•u h√¨nh ƒê·∫≠p H·ªôp")
def drop_config_menu(message):
    if message.from_user.id in admins:
        conf = get_drop_settings()
        markup = types.ReplyKeyboardMarkup(row_width=2, resize_keyboard=True)
        # Button b·∫≠t/t·∫Øt ƒë·∫≠p h·ªôp
        toggle_text = 'üî¥ T·∫ÆT ƒê·∫≠p H·ªôp' if conf.get('enabled', True) else 'üü¢ B·∫¨T ƒê·∫≠p H·ªôp'
        markup.add(types.KeyboardButton(toggle_text))
        markup.add(types.KeyboardButton('‚úèÔ∏è S·ª≠a ti√™u ƒë·ªÅ'))
        markup.add(types.KeyboardButton('‚è± S·ª≠a th·ªùi gian h·ª£p l·ªá'),
                   types.KeyboardButton('üïê S·ª≠a th·ªùi ƒëi·ªÉm r∆°i (HH:MM)'))
        markup.add(types.KeyboardButton('üì∑ Upload ·∫£nh ƒê·∫≠p H·ªôp'),
                   types.KeyboardButton('üßπ X√≥a ·∫£nh ƒê·∫≠p H·ªôp'))
        markup.add(types.KeyboardButton('‚ûï Th√™m CODE ƒê·∫≠p H·ªôp'),
                   types.KeyboardButton('üìú Xem CODE ƒê·∫≠p H·ªôp'))
        markup.add(types.KeyboardButton('üóë X√≥a h·∫øt CODE ƒê·∫≠p H·ªôp'))
        markup.add(types.KeyboardButton('üîô Quay l·∫°i menu admin'))

        text = (
            f"üéÅ <b>C·∫•u h√¨nh ƒê·∫≠p H·ªôp</b>\n\n"
            f"B·∫≠t: {'‚úÖ' if conf.get('enabled', True) else '‚ùå'}\n"
            f"Ti√™u ƒë·ªÅ: {conf.get('title','üéÅ ƒê·∫≠p H·ªôp')}\n"
            f"·∫¢nh: {conf.get('image_url','(tr·ªëng)')}\n"
            f"Th·ªùi gian h·ª£p l·ªá: {conf.get('window_minutes',15)} ph√∫t\n"
            f"Th·ªùi ƒëi·ªÉm r∆°i trong ng√†y: {conf.get('times', ['09:00', '21:00'])}\n"
        )
        bot.send_message(message.chat.id, text, reply_markup=markup, parse_mode='HTML')

# Handler cho button b·∫≠t/t·∫Øt ƒë·∫≠p h·ªôp
@bot.message_handler(func=lambda message: message.text in ['üî¥ T·∫ÆT ƒê·∫≠p H·ªôp', 'üü¢ B·∫¨T ƒê·∫≠p H·ªôp'])
def toggle_drop_enabled(message):
    if message.from_user.id in admins:
        try:
            settings = load_settings()
            settings.setdefault('drop', get_drop_settings())
            
            # Toggle tr·∫°ng th√°i enabled
            current_state = settings['drop'].get('enabled', True)
            new_state = not current_state
            settings['drop']['enabled'] = new_state
            
            save_settings(settings)
            
            # Th√¥ng b√°o k·∫øt qu·∫£
            status_text = "B·∫¨T" if new_state else "T·∫ÆT"
            status_emoji = "üü¢" if new_state else "üî¥"
            
            bot.send_message(
                message.chat.id,
                f"{status_emoji} <b>ƒê√É {status_text} ƒê·∫¨P H·ªòP</b>\n\n"
                f"Tr·∫°ng th√°i hi·ªán t·∫°i: {status_emoji} {status_text}",
                parse_mode='HTML'
            )
            
            # Quay l·∫°i menu c·∫•u h√¨nh ƒë·∫≠p h·ªôp
            drop_config_menu(message)
            
        except Exception as e:
            bot.send_message(
                message.chat.id,
                f"‚ùå L·ªói khi thay ƒë·ªïi tr·∫°ng th√°i ƒë·∫≠p h·ªôp: {str(e)}"
            )
    else:
        bot.reply_to(message, "‚ùå B·∫°n kh√¥ng c√≥ quy·ªÅn s·ª≠ d·ª•ng ch·ª©c nƒÉng n√†y!")

@bot.message_handler(func=lambda message: message.text == 'üñº S·ª≠a ·∫£nh ƒê·∫≠p H·ªôp')
def edit_drop_image(message):
    if message.from_user.id in admins:
        bot.send_message(message.chat.id, 'G·ª≠i URL ·∫£nh m·ªõi:')
        bot.register_next_step_handler(message, _save_drop_image)

def _save_drop_image(message):
    if message.from_user.id in admins:
        settings = load_settings()
        settings.setdefault('drop', get_drop_settings())
        settings['drop']['image_url'] = message.text.strip()
        save_settings(settings)
        drop_config_menu(message)

@bot.message_handler(func=lambda message: message.text == '‚úèÔ∏è S·ª≠a ti√™u ƒë·ªÅ')
def edit_drop_title(message):
    if message.from_user.id in admins:
        bot.send_message(message.chat.id, 'Nh·∫≠p ti√™u ƒë·ªÅ m·ªõi:')
        bot.register_next_step_handler(message, _save_drop_title)

def _save_drop_title(message):
    if message.from_user.id in admins:
        settings = load_settings()
        settings.setdefault('drop', get_drop_settings())
        settings['drop']['title'] = message.text.strip()
        save_settings(settings)
        drop_config_menu(message)

@bot.message_handler(func=lambda message: message.text == 'üì∑ Upload ·∫£nh ƒê·∫≠p H·ªôp')
def upload_drop_image_prompt(message):
    if message.from_user.id in admins:
        bot.send_message(message.chat.id, 'G·ª≠i ·∫£nh l√†m ·∫£nh ƒê·∫≠p H·ªôp (·∫£nh JPEG/PNG).')
        bot.register_next_step_handler(message, _save_drop_image_file)

def _save_drop_image_file(message):
    if message.from_user.id in admins:
        if message.content_type == 'photo':
            try:
                file_id = message.photo[-1].file_id
                settings = load_settings()
                settings.setdefault('drop', get_drop_settings())
                settings['drop']['image_file_id'] = file_id
                save_settings(settings)
                bot.send_message(message.chat.id, '‚úÖ ƒê√£ l∆∞u ·∫£nh t·∫£i l√™n cho ƒê·∫≠p H·ªôp.')
            except Exception as e:
                bot.send_message(message.chat.id, f'‚ùå L·ªói l∆∞u ·∫£nh: {e}')
        else:
            bot.send_message(message.chat.id, '‚ùå Vui l√≤ng g·ª≠i ƒë√∫ng lo·∫°i ·∫£nh.')
        drop_config_menu(message)

@bot.message_handler(func=lambda message: message.text == 'üßπ X√≥a ·∫£nh ƒê·∫≠p H·ªôp')
def clear_drop_image(message):
    if message.from_user.id in admins:
        settings = load_settings()
        settings.setdefault('drop', get_drop_settings())
        settings['drop']['image_file_id'] = ''
        settings['drop']['image_url'] = ''
        save_settings(settings)
        bot.send_message(message.chat.id, '‚úÖ ƒê√£ x√≥a c·∫•u h√¨nh ·∫£nh ƒê·∫≠p H·ªôp.')
        drop_config_menu(message)

@bot.message_handler(func=lambda message: message.text == '‚è± S·ª≠a th·ªùi gian h·ª£p l·ªá')
def edit_drop_window(message):
    if message.from_user.id in admins:
        bot.send_message(message.chat.id, 'Nh·∫≠p s·ªë ph√∫t (1-60):')
        bot.register_next_step_handler(message, _save_drop_window)

def _save_drop_window(message):
    if message.from_user.id in admins:
        try:
            minutes = max(1, min(60, int(message.text.strip())))
            settings = load_settings()
            settings.setdefault('drop', get_drop_settings())
            settings['drop']['window_minutes'] = minutes
            save_settings(settings)
        except Exception:
            pass
        drop_config_menu(message)

@bot.message_handler(func=lambda message: message.text == 'üïê S·ª≠a th·ªùi ƒëi·ªÉm r∆°i (HH:MM)')
def edit_drop_range(message):
    if message.from_user.id in admins:
        bot.send_message(message.chat.id, 'Nh·∫≠p danh s√°ch th·ªùi ƒëi·ªÉm d·∫°ng H1:M1,H2:M2 (vd: 9:20,10:20):')
        bot.register_next_step_handler(message, _save_drop_range)

def _save_drop_range(message):
    if message.from_user.id in admins:
        try:
            txt = message.text.replace(' ', '')
            parts = [p for p in txt.split(',') if p]
            times = []
            for p in parts:
                hh, mm = p.split(':')
                hh = max(0, min(23, int(hh)))
                mm = max(0, min(59, int(mm)))
                times.append(f"{hh:02d}:{mm:02d}")
            if not times:
                raise ValueError('empty')
            settings = load_settings()
            settings.setdefault('drop', get_drop_settings())
            settings['drop']['times'] = times
            save_settings(settings)
        except Exception:
            pass
        drop_config_menu(message)

@bot.message_handler(func=lambda message: message.text == 'üìç ƒê·∫∑t n∆°i g·ª≠i th√¥ng b√°o')
def set_drop_target(message):
    if message.from_user.id in admins:
        bot.send_message(message.chat.id, 
            'Nh·∫≠p Chat ID ƒë·ªÉ g·ª≠i th√¥ng b√°o ƒê·∫≠p H·ªôp:\n'
            '- G·ª≠i "all" ƒë·ªÉ g·ª≠i cho t·∫•t c·∫£ user\n'
            '- G·ª≠i Chat ID (s·ªë √¢m cho group/channel)\n'
            '- G·ª≠i "current" ƒë·ªÉ d√πng chat hi·ªán t·∫°i')
        bot.register_next_step_handler(message, _save_drop_target)

def _save_drop_target(message):
    if message.from_user.id in admins:
        try:
            text = message.text.strip().lower()
            if text == 'all':
                target = None
            elif text == 'current':
                target = message.chat.id
            else:
                target = int(text)
            settings = load_settings()
            settings.setdefault('drop', get_drop_settings())
            settings['drop']['target_chat_id'] = target
            save_settings(settings)
            bot.send_message(message.chat.id, f'‚úÖ ƒê√£ ƒë·∫∑t n∆°i g·ª≠i: {target if target else "T·∫•t c·∫£ user"}')
        except Exception as e:
            bot.send_message(message.chat.id, f'‚ùå L·ªói: {e}')
        drop_config_menu(message)

@bot.message_handler(func=lambda message: message.text == 'üåç ƒê·∫∑t m√∫i gi·ªù')
def set_timezone(message):
    if message.from_user.id in admins:
        bot.send_message(message.chat.id, 
            'Nh·∫≠p m√∫i gi·ªù (v√≠ d·ª•):\n'
            '- Asia/Ho_Chi_Minh (Vi·ªát Nam)\n'
            '- Asia/Bangkok (Th√°i Lan)\n'
            '- Asia/Shanghai (Trung Qu·ªëc)\n'
            '- Europe/London (Anh)\n'
            '- America/New_York (M·ªπ)\n'
            '- UTC (UTC+0)')
        bot.register_next_step_handler(message, _save_timezone)

def _save_timezone(message):
    if message.from_user.id in admins:
        try:
            tz_name = message.text.strip()
            # Test m√∫i gi·ªù c√≥ h·ª£p l·ªá kh√¥ng
            pytz.timezone(tz_name)
            settings = load_settings()
            settings.setdefault('drop', get_drop_settings())
            settings['drop']['timezone'] = tz_name
            save_settings(settings)
            bot.send_message(message.chat.id, f'‚úÖ ƒê√£ ƒë·∫∑t m√∫i gi·ªù: {tz_name}')
        except Exception as e:
            bot.send_message(message.chat.id, f'‚ùå M√∫i gi·ªù kh√¥ng h·ª£p l·ªá: {e}')
        drop_config_menu(message)

@bot.message_handler(func=lambda message: message.text == 'üöÄ Test g·ª≠i ƒê·∫≠p H·ªôp')
def test_send_drop(message):
    if message.from_user.id in admins:
        broadcast_drop_announcement(message.chat.id)
        bot.reply_to(message, 'ƒê√£ g·ª≠i th·ª≠ th√¥ng b√°o ƒê·∫≠p H·ªôp v√†o chat hi·ªán t·∫°i.')

@bot.message_handler(func=lambda message: message.text == '‚ûï Th√™m CODE ƒê·∫≠p H·ªôp')
def add_drop_codes(message):
    if message.from_user.id in admins:
        bot.send_message(message.chat.id, 'G·ª≠i danh s√°ch CODE (m·ªói d√≤ng 1 CODE):')
        bot.register_next_step_handler(message, _save_drop_codes)

def _save_drop_codes(message):
    if message.from_user.id in admins:
        global drop_codes
        lines = [l.strip() for l in message.text.split('\n') if l.strip()]
        before = set(drop_codes)
        drop_codes.extend([c for c in lines if c not in before])
        drop_codes = list(dict.fromkeys(drop_codes))
        save_drop_codes()
        bot.send_message(message.chat.id, f'ƒê√£ th√™m {len(lines)} CODE. T·ªïng: {len(drop_codes)}')
        drop_config_menu(message)

@bot.message_handler(func=lambda message: message.text == 'üìú Xem CODE ƒê·∫≠p H·ªôp')
def view_drop_codes(message):
    if message.from_user.id in admins:
        if not drop_codes:
            bot.send_message(message.chat.id, 'Hi·ªán kh√¥ng c√≥ CODE ƒê·∫≠p H·ªôp n√†o.')
        else:
            show = '\n'.join(f"{i+1}. {c}" for i, c in enumerate(drop_codes[:50]))
            more = '' if len(drop_codes) <= 50 else f"\n... v√† {len(drop_codes)-50} CODE kh√°c"
            bot.send_message(message.chat.id, f"üìú CODE ƒê·∫≠p H·ªôp ({len(drop_codes)}):\n\n{show}{more}")
        drop_config_menu(message)

@bot.message_handler(func=lambda message: message.text == 'üóë X√≥a h·∫øt CODE ƒê·∫≠p H·ªôp')
def clear_drop_codes(message):
    if message.from_user.id in admins:
        global drop_codes
        drop_codes = []
        save_drop_codes()
        bot.send_message(message.chat.id, 'ƒê√£ x√≥a to√†n b·ªô CODE ƒê·∫≠p H·ªôp.')
        drop_config_menu(message)


# Menu qu·∫£n l√Ω CODE
def code_management_menu(message):
    if message.from_user.id in admins:
        markup = types.ReplyKeyboardMarkup(row_width=2, resize_keyboard=True)
        markup.add(types.KeyboardButton('‚ûï Th√™m CODE'),
                   types.KeyboardButton('üìú Danh s√°ch CODE c√≥ s·∫µn'))
        markup.add(types.KeyboardButton('üìä Th·ªëng k√™ CODE ƒë√£ d√πng'),
                   types.KeyboardButton('‚ûñ X√≥a nhi·ªÅu CODE'))
        auto_status = "üü¢ T·∫ÆT" if auto_approve else "üî¥ B·∫¨T"
        markup.add(types.KeyboardButton(f'‚öôÔ∏è Duy·ªát t·ª± ƒë·ªông ({auto_status})'))
        markup.add(types.KeyboardButton('üîô Quay l·∫°i menu admin'))

        bot.send_message(
            message.chat.id,
            "üéÅ <b>Qu·∫£n l√Ω CODE</b>\n\nCh·ªçn ch·ª©c nƒÉng b·∫°n mu·ªën s·ª≠ d·ª•ng:",
            reply_markup=markup,
            parse_mode='HTML')

# NEW: Handler for ‚ûï Th√™m CODE
@bot.message_handler(func=lambda message: message.text == "‚ûï Th√™m CODE")
def handle_add_code(message):
    if message.from_user.id in admins:
        bot.send_message(
            message.chat.id,
            "üìù <b>TH√äM CODE M·ªöI</b>\n\n"
            "Vui l√≤ng nh·∫≠p danh s√°ch CODE (m·ªói code m·ªôt d√≤ng):\n\n"
            "üìã <b>V√≠ d·ª•:</b>\n"
            "CODE001\n"
            "CODE002\n"
            "CODE003\n\n"
            "‚ö†Ô∏è <b>L∆∞u √Ω:</b> M·ªói code m·ªôt d√≤ng ri√™ng bi·ªát",
            parse_mode='HTML'
        )
        bot.register_next_step_handler(message, process_add_code)

def process_add_code(message):
    if message.from_user.id in admins:
        try:
            # Split by lines and clean up
            new_codes = [code.strip() for code in message.text.split('\n') if code.strip()]
            
            if not new_codes:
                bot.send_message(
                    message.chat.id,
                    "‚ùå Kh√¥ng c√≥ CODE n√†o ƒë∆∞·ª£c nh·∫≠p. Vui l√≤ng th·ª≠ l·∫°i."
                )
                code_management_menu(message)
                return
            
            # Check for duplicates
            global codes
            duplicates = []
            added_codes = []
            
            for code in new_codes:
                if code in codes:
                    duplicates.append(code)
                else:
                    codes.append(code)
                    added_codes.append(code)
            
            # Save to file
            save_codes()
            
            # Create response message
            response = f"‚úÖ <b>ƒê√É TH√äM CODE TH√ÄNH C√îNG</b>\n\n"
            
            if added_codes:
                response += f"üìä <b>ƒê√£ th√™m {len(added_codes)} CODE m·ªõi:</b>\n"
                for i, code in enumerate(added_codes[:10], 1):  # Show max 10 codes
                    response += f"{i}. <code>{code}</code>\n"
                
                if len(added_codes) > 10:
                    response += f"... v√† {len(added_codes) - 10} CODE kh√°c\n"
            
            if duplicates:
                response += f"\n‚ö†Ô∏è <b>B·ªè qua {len(duplicates)} CODE tr√πng l·∫∑p:</b>\n"
                for i, code in enumerate(duplicates[:5], 1):  # Show max 5 duplicates
                    response += f"{i}. <code>{code}</code>\n"
                
                if len(duplicates) > 5:
                    response += f"... v√† {len(duplicates) - 5} CODE kh√°c\n"
            
            response += f"\nüìà <b>T·ªïng s·ªë CODE hi·ªán c√≥:</b> {len(codes)}"
            
            bot.send_message(message.chat.id, response, parse_mode='HTML')
            
            # Log the action
            log_debug(f"Admin {message.from_user.id} added {len(added_codes)} new codes")
            
        except Exception as e:
            log_error(f"Error in process_add_code: {e}")
            bot.send_message(
                message.chat.id,
                f"‚ùå C√≥ l·ªói x·∫£y ra khi th√™m CODE: {str(e)}"
            )
        
        # Return to code management menu
        code_management_menu(message)

# Handler for viewing available codes
@bot.message_handler(func=lambda message: message.text == "üìú Danh s√°ch CODE c√≥ s·∫µn")
def view_available_codes(message):
    if message.from_user.id in admins:
        if not codes:
            bot.send_message(
                message.chat.id,
                "‚ùå <b>DANH S√ÅCH CODE TR·ªêNG</b>\n\nHi·ªán t·∫°i kh√¥ng c√≥ CODE n√†o trong h·ªá th·ªëng.",
                parse_mode='HTML'
            )
        else:
            response = f"üìú <b>DANH S√ÅCH CODE C√ì S·∫¥N</b>\n\n"
            response += f"üìä <b>T·ªïng s·ªë CODE:</b> {len(codes)}\n\n"
            
            # Show first 20 codes
            for i, code in enumerate(codes[:20], 1):
                response += f"{i}. <code>{code}</code>\n"
            
            if len(codes) > 20:
                response += f"\n... v√† {len(codes) - 20} CODE kh√°c"
            
            bot.send_message(message.chat.id, response, parse_mode='HTML')
        
        # Return to code management menu
        code_management_menu(message)

# Handler for viewing used codes statistics
@bot.message_handler(func=lambda message: message.text == "üìä Th·ªëng k√™ CODE ƒë√£ d√πng")
def view_used_codes_stats(message):
    if message.from_user.id in admins:
        if not used_codes:
            bot.send_message(
                message.chat.id,
                "‚ùå <b>CH∆ØA C√ì CODE N√ÄO ƒê∆Ø·ª¢C S·ª¨ D·ª§NG</b>\n\nHi·ªán t·∫°i ch∆∞a c√≥ CODE n√†o ƒë∆∞·ª£c ƒë·ªïi.",
                parse_mode='HTML'
            )
        else:
            response = f"üìä <b>TH·ªêNG K√ä CODE ƒê√É D√ôNG</b>\n\n"
            response += f"üî¢ <b>T·ªïng s·ªë CODE ƒë√£ d√πng:</b> {len(used_codes)}\n\n"
            
            # Calculate total amount
            total_amount = sum(info.get('amount', 0) for info in used_codes.values())
            response += f"üí∞ <b>T·ªïng gi√° tr·ªã ƒë√£ ƒë·ªïi:</b> {total_amount:,} VNƒê\n\n"
            
            response += f"üìà <b>10 CODE g·∫ßn ƒë√¢y nh·∫•t:</b>\n"
            
            # Sort by time (assuming time format is consistent)
            sorted_codes = sorted(
                used_codes.items(),
                key=lambda x: x[1].get('time', ''),
                reverse=True
            )
            
            for i, (code, info) in enumerate(sorted_codes[:10], 1):
                user_id = info.get('user_id', 'N/A')
                amount = info.get('amount', 0)
                time_str = info.get('time', 'N/A')
                response += f"{i}. <code>{code}</code> - User {user_id} - {amount:,}‚Ç´ - {time_str}\n"
            
            bot.send_message(message.chat.id, response, parse_mode='HTML')
        
        # Return to code management menu
        code_management_menu(message)

# Handler for toggle auto approve
@bot.message_handler(func=lambda message: message.text.startswith("‚öôÔ∏è Duy·ªát t·ª± ƒë·ªông"))
def toggle_auto_approve(message):
    if message.from_user.id in admins:
        global auto_approve
        auto_approve = not auto_approve
        status = "B·∫¨T" if auto_approve else "T·∫ÆT"
        
        bot.send_message(
            message.chat.id,
            f"‚úÖ <b>ƒê√É C·∫¨P NH·∫¨T C√ÄI ƒê·∫∂T</b>\n\n"
            f"ü§ñ Duy·ªát t·ª± ƒë·ªông hi·ªán ƒëang: <b>{status}</b>\n\n"
            f"{'üìå C√°c y√™u c·∫ßu ƒë·ªïi CODE s·∫Ω ƒë∆∞·ª£c duy·ªát t·ª± ƒë·ªông' if auto_approve else 'üìå C√°c y√™u c·∫ßu ƒë·ªïi CODE c·∫ßn duy·ªát th·ªß c√¥ng'}",
            parse_mode='HTML'
        )
        
        # Return to code management menu
        code_management_menu(message)

@bot.message_handler(func=lambda message: message.text == "‚ûñ X√≥a nhi·ªÅu CODE")
def remove_code_command(message):
    if message.from_user.id in admins:
        if not codes:
            bot.send_message(message.chat.id, "‚ùå Kh√¥ng c√≥ CODE n√†o ƒë·ªÉ x√≥a.")
            return

        markup = types.InlineKeyboardMarkup(row_width=1)
        for i, code in enumerate(codes[:30]):  # hi·ªÉn th·ªã t·ªëi ƒëa 30 code ƒë·∫ßu
            markup.add(types.InlineKeyboardButton(f"{code}", callback_data=f"remove_code_{i}"))

        bot.send_message(
            message.chat.id,
            "üóë Ch·ªçn CODE b·∫°n mu·ªën x√≥a:",
            reply_markup=markup
        )

@bot.callback_query_handler(func=lambda call: call.data.startswith("remove_code_"))
def handle_remove_code(call):
    if call.from_user.id in admins:
        index = int(call.data.split("_")[2])
        if 0 <= index < len(codes):
            removed_code = codes.pop(index)
            save_codes()
            bot.answer_callback_query(call.id, f"‚úÖ ƒê√£ x√≥a CODE: {removed_code}")
            bot.edit_message_text(
                f"üóë CODE <code>{removed_code}</code> ƒë√£ ƒë∆∞·ª£c x√≥a kh·ªèi h·ªá th·ªëng.",
                call.message.chat.id,
                call.message.message_id,
                parse_mode="HTML"
            )
        else:
            bot.answer_callback_query(call.id, "‚ùå CODE kh√¥ng t·ªìn t·∫°i!")

# Handler cho l·ªánh /xoacode (x√≥a nhi·ªÅu CODE c√πng l√∫c)
@bot.message_handler(commands=['xoacode'])
def delete_multiple_codes(message):
    if message.from_user.id not in admins:
        return
    
    # B·ªè d√≤ng ƒë·∫ßu "/xoacode", l·∫•y c√°c d√≤ng ti·∫øp theo
    parts = message.text.split("\n")[1:]
    codes_to_delete = [p.strip() for p in parts if p.strip()]

    if not codes_to_delete:
        bot.reply_to(message, "‚ùå Vui l√≤ng nh·∫≠p √≠t nh·∫•t 1 CODE ƒë·ªÉ x√≥a.\nV√≠ d·ª•:\n/xoacode CODE1\nCODE2\nCODE3")
        return
    
    deleted = []
    not_found = []
    
    global codes
    for c in codes_to_delete:
        if c in codes:
            codes.remove(c)
            deleted.append(c)
        else:
            not_found.append(c)
    
    save_codes()  # l∆∞u l·∫°i file codes.json
    
    response = "üìä **K·∫æT QU·∫¢ X√ìA CODE**\n\n"
    
    if deleted:
        response += f"‚úÖ **ƒê√£ x√≥a {len(deleted)} CODE:**\n"
        for code in deleted:
            response += f"- {code}\n"
    
    if not_found:
        response += f"\n‚ùå **Kh√¥ng t√¨m th·∫•y {len(not_found)} CODE:**\n"
        for code in not_found:
            response += f"- {code}\n"
    
    bot.reply_to(message, response, parse_mode='Markdown')

# Menu c√†i ƒë·∫∑t h·ªá th·ªëng
def system_settings_menu(message):
    if message.from_user.id in admins:
        settings = load_settings()
        markup = types.ReplyKeyboardMarkup(row_width=2, resize_keyboard=True)
        markup.add(types.KeyboardButton('üí∞ ƒê·ªïi th∆∞·ªüng gi·ªõi thi·ªáu'),
                   types.KeyboardButton('üí≤ ƒê·ªïi m·ª©c r√∫t t·ªëi thi·ªÉu'))
        markup.add(types.KeyboardButton('üîô Quay l·∫°i menu admin'))

        bot.send_message(
            message.chat.id, f"üì± <b>C√†i ƒë·∫∑t h·ªá th·ªëng</b>\n\n"
            f"üî∏ Th∆∞·ªüng gi·ªõi thi·ªáu hi·ªán t·∫°i: {settings['referral_bonus']} VNƒê\n"
            f"üî∏ M·ª©c r√∫t t·ªëi thi·ªÉu hi·ªán t·∫°i: {settings['min_withdraw']} VNƒê\n\n"
            f"Ch·ªçn c√†i ƒë·∫∑t b·∫°n mu·ªën thay ƒë·ªïi:",
            reply_markup=markup,
            parse_mode='HTML')

# X·ª≠ l√Ω l·ªánh /start - UPDATED to use enhanced subscription check
@bot.message_handler(commands=['start'])
def handle_start(message):
    user_id = message.from_user.id
    referrer_id = None
    add_user(user_id)

    # N·∫øu l√† admin, hi·ªÉn th·ªã menu admin ngay
    if user_id in admins:
        # Display User Menu and Balance v√† Menu Admin
        markup = types.ReplyKeyboardMarkup(row_width=2, resize_keyboard=True)
        markup.add(types.KeyboardButton('üë§T√ÄI KHO·∫¢N'),
                   types.KeyboardButton('üë•M·ªúI B·∫†N B√à'))
        markup.add(types.KeyboardButton('üéÆLINK GAME'),
                   types.KeyboardButton('üéÅƒê·ªîI CODE'))
        markup.add(types.KeyboardButton('üìäTH·ªêNG K√ä'))
        markup.add(types.KeyboardButton('üëë MENU ADMIN'))

        bot.send_message(
            message.chat.id,
            f"üëã Ch√†o m·ª´ng admin! B·∫°n c√≥ quy·ªÅn truy c·∫≠p menu admin.\nüí∞ S·ªë d∆∞ c·ªßa b·∫°n: {get_balance(user_id)} VNƒê",
            reply_markup=markup)
        return

    # Check for referral code in message
    if len(message.text.split()) > 1:
        referrer_id = message.text.split()[1]

        if str(user_id) not in user_data:  # Process only if user account doesn't exist
            invited_users[str(user_id)] = referrer_id
            save_data(invited_users_file, invited_users)

            # Th√™m v√†o l·ªãch s·ª≠ ng∆∞·ªùi gi·ªõi thi·ªáu
            if referrer_id not in referral_history:
                referral_history[referrer_id] = []
            referral_history[referrer_id].append(str(user_id))
            save_referral_history()

    # T·∫£i danh s√°ch nh√≥m m·ªõi nh·∫•t t·ª´ file
    channels = load_channels()  # channels c√≥ th·ªÉ l√† list chu·ªói "@name" ho·∫∑c list dict {"username": "@..", "title": "T√™n"}

    # N·∫øu kh√¥ng c√≥ k√™nh n√†o ‚Üí cho v√†o menu ch√≠nh
    if not channels:
        main_markup = types.ReplyKeyboardMarkup(row_width=2, resize_keyboard=True)
        main_markup.add(types.KeyboardButton('üë§T√ÄI KHO·∫¢N'),
                        types.KeyboardButton('üë•M·ªúI B·∫†N B√à'))
        main_markup.add(types.KeyboardButton('üéÆLINK GAME'),
                        types.KeyboardButton('üéÅƒê·ªîI CODE'))
        main_markup.add(types.KeyboardButton('üìäTH·ªêNG K√ä'))

        # ch·ªâ hi·ªán khi l√† admin
        if user_id in admins:
            main_markup.add(types.KeyboardButton('üëë MENU ADMIN'))

        bot.send_message(message.chat.id, "üìå Ch√†o! Ch·ªçn ch·ª©c nƒÉng:", reply_markup=main_markup)
        return

    # N·∫øu c√≥ k√™nh: ki·ªÉm tra ƒë√£ tham gia hay ch∆∞a
    if check_subscription_with_retry(user_id):
        # ƒê√£ tham gia ƒë·∫ßy ƒë·ªß ‚Üí hi·ªÉn th·ªã menu ch√≠nh ngay
        main_markup = types.ReplyKeyboardMarkup(row_width=2, resize_keyboard=True)
        main_markup.add(types.KeyboardButton('üë§T√ÄI KHO·∫¢N'),
                        types.KeyboardButton('üë•M·ªúI B·∫†N B√à'))
        main_markup.add(types.KeyboardButton('üéÆLINK GAME'),
                        types.KeyboardButton('üéÅƒê·ªîI CODE'))
        main_markup.add(types.KeyboardButton('üìäTH·ªêNG K√ä'))

        # Th√™m n√∫t menu admin n·∫øu l√† admin
        if user_id in admins:
            main_markup.add(types.KeyboardButton('üëë MENU ADMIN'))

        balance = get_balance(user_id)
        bot.send_message(message.chat.id,
                         f"Ch√†o b·∫°n quay l·∫°i! S·ªë d∆∞ c·ªßa b·∫°n l√† {balance} VNƒê.",
                         reply_markup=main_markup)
        return

    # Ch∆∞a tham gia ƒë·∫ßy ƒë·ªß ‚Üí hi·ªÉn th·ªã danh s√°ch k√™nh v√† n√∫t x√°c minh
    markup = types.InlineKeyboardMarkup(row_width=1)

    for ch in channels:
        if isinstance(ch, dict):
            username = ch.get("username", "").lstrip('@').strip()
            title = ch.get("title", ch.get("username", "")).strip()
        else:
            username = str(ch).lstrip('@').strip()
            title = f"üîó @{username}"

        if username:
            url = f"https://t.me/{username}"
            markup.add(types.InlineKeyboardButton(title, url=url))
    # Add verification button at the bottom
    markup.add(types.InlineKeyboardButton('‚úÖ X√ÅC MINH THAM GIA', callback_data='check'))

    message_text = (
        "<b>‚ö†Ô∏è Vui l√≤ng tham gia t·∫•t c·∫£ c√°c nh√≥m/k√™nh sau ƒë·ªÉ nh·∫≠n code:</b>\n\n"
        "<b>‚Ä¢ Sau khi tham gia, nh·∫•n \"‚úÖ X√ÅC MINH THAM GIA\" ƒë·ªÉ ti·∫øp t·ª•c.</b>"
    )

    sent = bot.send_message(message.chat.id,
                            message_text,
                            reply_markup=markup,
                            parse_mode='HTML')
    try:
        user_key = str(user_id)
        user_data.setdefault(user_key, {})['last_join_prompt'] = {
            'chat_id': message.chat.id,
            'message_id': sent.message_id
        }
        save_user_data(user_data)
    except Exception as _:
        pass

# Check Channels Command Handler - UPDATED to use enhanced subscription check
@bot.callback_query_handler(func=lambda call: call.data == 'check')
def check_channels(call):
    user_id = call.from_user.id

    # ‚úÖ Ch·ªâ ki·ªÉm tra ƒë√£ tham gia k√™nh hay ch∆∞a
    if check_subscription_with_retry(user_id):
        # N·∫øu ƒë√£ tham gia h·∫øt ‚Üí m·ªü menu user
        main_markup = types.ReplyKeyboardMarkup(row_width=2, resize_keyboard=True)
        main_markup.add(types.KeyboardButton('üë§T√ÄI KHO·∫¢N'),
                        types.KeyboardButton('üë•M·ªúI B·∫†N B√à'))
        main_markup.add(types.KeyboardButton('üéÆLINK GAME'),
                        types.KeyboardButton('üéÅƒê·ªîI CODE'))
        main_markup.add(types.KeyboardButton('üìäTH·ªêNG K√ä'))

        # N·∫øu l√† admin th√™m menu admin
        if user_id in admins:
            main_markup.add(types.KeyboardButton('üëë MENU ADMIN'))

        bot.send_message(call.message.chat.id,
                         "‚úÖ B·∫°n ƒë√£ tham gia ƒë·∫ßy ƒë·ªß c√°c k√™nh!\nCh√†o m·ª´ng ƒë·∫øn v·ªõi h·ªá th·ªëng üéâ",
                         reply_markup=main_markup)
    else:
        # N·∫øu ch∆∞a tham gia ƒë·ªß k√™nh ‚Üí th√¥ng b√°o l·ªói
        bot.answer_callback_query(call.id,
                                  text='‚ö†Ô∏è B·∫°n ch∆∞a tham gia ƒë·∫ßy ƒë·ªß c√°c k√™nh y√™u c·∫ßu!',
                                  show_alert=True)

# X·ª≠ l√Ω n√∫t menu admin
@bot.message_handler(func=lambda message: message.text == "üëë MENU ADMIN")
def handle_admin_menu(message):
    # Kh·ªüi t·∫°o ng∆∞·ªùi d√πng n·∫øu ch∆∞a c√≥ (ƒë·∫£m b·∫£o d·ªØ li·ªáu)
    if str(message.from_user.id) not in user_data:
        initialize_user(message.from_user.id)
        
    admin_menu(message)
    
# X·ª≠ l√Ω c√°c n√∫t trong menu admin
@bot.message_handler(func=lambda message: message.text == "üìã Qu·∫£n l√Ω nh√≥m")
def handle_manage_channels(message):
    # ƒê·∫£m b·∫£o h√†m n√†y g·ªçi menu qu·∫£n l√Ω nh√≥m m·ªõi
    channel_management_menu(message)

# Handler for menu code management
@bot.message_handler(func=lambda message: message.text == "üéÅ Qu·∫£n l√Ω CODE")
def handle_code_management(message):
    if message.from_user.id in admins:
        code_management_menu(message)
    else:
        bot.reply_to(message, "‚ùå B·∫°n kh√¥ng c√≥ quy·ªÅn truy c·∫≠p ch·ª©c nƒÉng n√†y!")

# Handler for system settings
@bot.message_handler(func=lambda message: message.text == "‚öôÔ∏è C√†i ƒë·∫∑t h·ªá th·ªëng")
def handle_system_settings(message):
    if message.from_user.id in admins:
        system_settings_menu(message)
    else:
        bot.reply_to(message, "‚ùå B·∫°n kh√¥ng c√≥ quy·ªÅn truy c·∫≠p ch·ª©c nƒÉng n√†y!")
    
# Menu qu·∫£n l√Ω nh√≥m - S·ª¨ D·ª§NG ReplyKeyboardMarkup
@bot.message_handler(func=lambda message: message.text == "üìã Qu·∫£n l√Ω nh√≥m" or message.text == "üîô Quay l·∫°i menu qu·∫£n l√Ω nh√≥m")

def channel_management_menu(message):
    if message.from_user.id in admins:
        markup = types.ReplyKeyboardMarkup(row_width=2, resize_keyboard=True)

        markup.add(
            types.KeyboardButton('üìã Xem danh s√°ch nh√≥m'),
            types.KeyboardButton('‚úèÔ∏è ƒê·ªïi T√™n Nh√≥m')
        )
        markup.add(
            types.KeyboardButton('‚ûñ X√≥a nh√≥m'),
            types.KeyboardButton('‚ûï Th√™m nh√≥m')
        )
        markup.add(
            types.KeyboardButton('üîç Ki·ªÉm tra quy·ªÅn admin'),
            types.KeyboardButton('üîô Quay l·∫°i menu admin')
        )
        
        bot.send_message(
            message.chat.id,
            "üìã <b>Qu·∫£n l√Ω nh√≥m</b>\n\nCh·ªçn ch·ª©c nƒÉng b·∫°n mu·ªën s·ª≠ d·ª•ng:",
            reply_markup=markup,
            parse_mode='HTML' 
        )
        
        

# [Continue with ALL callback handlers and remaining functions from original file...]

@bot.message_handler(func=lambda message: message.text == "üìã Xem danh s√°ch nh√≥m")
def handle_view_channels(message):
    if message.from_user.id not in admins:
        return
    channels = load_channels()
    if channels:
        text = "üìã <b>Danh s√°ch nh√≥m/k√™nh hi·ªán t·∫°i:</b>\n\n"
        for i, channel in enumerate(channels, 1):
            if isinstance(channel, dict):
                username = channel.get('username', 'Kh√¥ng x√°c ƒë·ªãnh')
                title = channel.get('title', username)
                text += f"{i}. <code>@{username}</code> - {title}\n"
            else:
                username = str(channel).lstrip('@')
                text += f"{i}. <code>@{username}</code>\n"
        
        # Quay l·∫°i menu qu·∫£n l√Ω nh√≥m
        markup = types.ReplyKeyboardMarkup(row_width=1, resize_keyboard=True)
        markup.add(types.KeyboardButton('üîô Quay l·∫°i menu qu·∫£n l√Ω nh√≥m'))
        
        bot.send_message(
            message.chat.id,
            text,
            reply_markup=markup,
            parse_mode='HTML'
        )
    else:
        # Quay l·∫°i menu qu·∫£n l√Ω nh√≥m
        markup = types.ReplyKeyboardMarkup(row_width=1, resize_keyboard=True)
        markup.add(types.KeyboardButton('üîô Quay l·∫°i menu qu·∫£n l√Ω nh√≥m'))
        
        bot.send_message(
            message.chat.id,
            "üìã <b>Danh s√°ch nh√≥m/k√™nh:</b>\n\n‚ùå Ch∆∞a c√≥ nh√≥m/k√™nh n√†o ƒë∆∞·ª£c th√™m.",
            reply_markup=markup,
            parse_mode='HTML'
        )

# Th√™m handler cho n√∫t Quay l·∫°i menu qu·∫£n l√Ω nh√≥m
@bot.message_handler(func=lambda message: message.text == "üîô Quay l·∫°i menu qu·∫£n l√Ω nh√≥m")
def back_to_channel_management(message):
    channel_management_menu(message)
    
    

# Add ALL remaining handlers and functions from the original 1857-line file...
# [This includes ALL the missing handlers for code exchange, admin functions, etc.]

@bot.message_handler(
    func=lambda message: message.text == "üí∞ ƒê·ªïi th∆∞·ªüng gi·ªõi thi·ªáu")
def change_referral_bonus(message):
    if message.from_user.id in admins:
        bot.send_message(
            message.chat.id,
            "Vui l√≤ng nh·∫≠p s·ªë ti·ªÅn th∆∞·ªüng cho m·ªói l∆∞·ª£t gi·ªõi thi·ªáu (VNƒê):")
        bot.register_next_step_handler(message, process_referral_bonus)

def process_referral_bonus(message):
    if message.from_user.id in admins:
        try:
            amount = int(message.text.strip())
            if amount < 0:
                bot.send_message(
                    message.chat.id,
                    "S·ªë ti·ªÅn kh√¥ng h·ª£p l·ªá. Vui l√≤ng nh·∫≠p s·ªë d∆∞∆°ng.")
                return

            settings = load_settings()
            settings['referral_bonus'] = amount
            save_settings(settings)

            bot.send_message(
                message.chat.id,
                f"‚úÖ ƒê√£ c·∫≠p nh·∫≠t m·ª©c th∆∞·ªüng gi·ªõi thi·ªáu th√†nh {amount} VNƒê m·ªói l∆∞·ª£t gi·ªõi thi·ªáu."
            )

            # Quay l·∫°i menu c√†i ƒë·∫∑t
            system_settings_menu(message)

        except ValueError:
            bot.send_message(message.chat.id, "Vui l√≤ng nh·∫≠p m·ªôt s·ªë h·ª£p l·ªá.")

@bot.message_handler(func=lambda message: message.text == "üí≤ ƒê·ªïi m·ª©c r√∫t t·ªëi thi·ªÉu")
def change_min_withdraw(message):
    if message.from_user.id in admins:
        bot.send_message(message.chat.id,
                         "Vui l√≤ng nh·∫≠p s·ªë ti·ªÅn r√∫t t·ªëi thi·ªÉu (VNƒê):")
        bot.register_next_step_handler(message, process_min_withdraw)

def process_min_withdraw(message):
    if message.from_user.id in admins:
        try:
            amount = int(message.text.strip())
            if amount < 0:
                bot.send_message(
                    message.chat.id,
                    "S·ªë ti·ªÅn kh√¥ng h·ª£p l·ªá. Vui l√≤ng nh·∫≠p s·ªë d∆∞∆°ng.")
                return

            settings = load_settings()
            settings['min_withdraw'] = amount
            save_settings(settings)

            # C·∫≠p nh·∫≠t bi·∫øn to√†n c·ª•c
            global min_withdraw_amount
            min_withdraw_amount = amount

            bot.send_message(
                message.chat.id,
                f"‚úÖ ƒê√£ c·∫≠p nh·∫≠t m·ª©c r√∫t ti·ªÅn t·ªëi thi·ªÉu th√†nh {amount} VNƒê."
            )

            # Quay l·∫°i menu c√†i ƒë·∫∑t
            system_settings_menu(message)

        except ValueError:
            bot.send_message(message.chat.id, "Vui l√≤ng nh·∫≠p m·ªôt s·ªë h·ª£p l·ªá.")

@bot.message_handler(func=lambda message: message.text == "üì¢ Th√¥ng b√°o to√†n h·ªá th·ªëng")
def broadcast_message_command(message):
    if message.from_user.id in admins:
        bot.send_message(
            message.chat.id,
            "Vui l√≤ng nh·∫≠p n·ªôi dung th√¥ng b√°o mu·ªën g·ª≠i ƒë·∫øn t·∫•t c·∫£ ng∆∞·ªùi d√πng:")
        bot.register_next_step_handler(message, process_broadcast_message)

def process_broadcast_message(message):
    if message.from_user.id in admins:
        announcement = message.text

        # X√°c nh·∫≠n tr∆∞·ªõc khi g·ª≠i
        markup = types.InlineKeyboardMarkup()
        markup.add(
            types.InlineKeyboardButton("‚úÖ G·ª≠i",
                                       callback_data="confirm_broadcast"),
            types.InlineKeyboardButton("‚ùå H·ªßy",
                                       callback_data="cancel_broadcast"))

        # L∆∞u tin nh·∫Øn v√†o context ƒë·ªÉ s·ª≠ d·ª•ng sau n√†y
        bot.send_message(
            message.chat.id,
            f"<b>X√°c nh·∫≠n g·ª≠i th√¥ng b√°o n√†y ƒë·∫øn t·∫•t c·∫£ ng∆∞·ªùi d√πng?</b>\n\n{announcement}",
            reply_markup=markup,
            parse_mode='HTML')

        # L∆∞u tin nh·∫Øn ƒë·ªÉ g·ª≠i sau
        if str(message.from_user.id) not in user_data:
            user_data[str(message.from_user.id)] = {}
        user_data[str(
            message.from_user.id)]['broadcast_message'] = announcement

@bot.callback_query_handler(
    func=lambda call: call.data in ["confirm_broadcast", "cancel_broadcast"])
def handle_broadcast_confirmation(call):
    user_id = call.from_user.id

    # Ki·ªÉm tra c√≥ m·ªùi b·∫°n th√†nh c√¥ng trong 60 ph√∫t g·∫ßn nh·∫•t kh√¥ng
    referrals = get_referred_users(user_id)
    if not referrals:
        bot.answer_callback_query(call.id, text='‚ùå B·∫°n c·∫ßn m·ªùi √≠t nh·∫•t 1 ng∆∞·ªùi trong 60 ph√∫t g·∫ßn nh·∫•t ƒë·ªÉ nh·∫≠n h·ªôp!', show_alert=True)
        return


    if user_id in admins:
        if call.data == "confirm_broadcast":
            announcement = user_data[str(user_id)].get('broadcast_message', '')
            if announcement:
                bot.edit_message_text(
                    "‚è≥ ƒêang g·ª≠i th√¥ng b√°o ƒë·∫øn t·∫•t c·∫£ ng∆∞·ªùi d√πng...",
                    call.message.chat.id, call.message.message_id)
                success_count = 0
                fail_count = 0

                for user_id in user_data.keys():
                    try:
                        bot.send_message(
                            user_id,
                            f"<b>üì¢ TH√îNG B√ÅO H·ªÜ TH·ªêNG</b>\n\n{announcement}",
                            parse_mode='HTML')
                        success_count += 1
                    except Exception as e:
                        fail_count += 1
                        log_error(
                            f"G·ª≠i th√¥ng b√°o cho user_id {user_id} kh√¥ng th√†nh c√¥ng: {str(e)}"
                        )

                bot.send_message(
                    call.message.chat.id,
                    f"‚úÖ ƒê√£ g·ª≠i th√¥ng b√°o ƒë·∫øn {success_count} ng∆∞·ªùi d√πng th√†nh c√¥ng!\n‚ùå Kh√¥ng g·ª≠i ƒë∆∞·ª£c cho {fail_count} ng∆∞·ªùi d√πng."
                )
            else:
                bot.edit_message_text(
                    "‚ùå L·ªói: Kh√¥ng t√¨m th·∫•y n·ªôi dung th√¥ng b√°o.",
                    call.message.chat.id, call.message.message_id)
        else:
            bot.edit_message_text("‚ùå ƒê√£ h·ªßy g·ª≠i th√¥ng b√°o.",
                                  call.message.chat.id,
                                  call.message.message_id)

@bot.message_handler(func=lambda message: message.text == "üìäTH·ªêNG K√ä")
def show_statistics(message):
    user_id = message.from_user.id
    
    if user_id in admins:
        # Th·ªëng k√™ cho ADMIN - T·ªïng t·∫•t c·∫£ c·ªßa c√°c user
        total_users = count_users()
        total_balance = sum(data.get('balance', 0) for data in user_data.values())
        total_withdrawals = sum(data.get('withdrawals', 0) for data in user_data.values())
        total_invites = sum(data.get('invited_count', 0) for data in user_data.values())
        channels_count = len(load_channels())
        codes_count = len(codes)
        used_codes_count = len(used_codes)
        drop_codes_count = len(drop_codes)

        stats = f"""
‚ïî‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïó
‚ïë        üìä TH·ªêNG K√ä H·ªÜ TH·ªêNG        ‚ïë
‚ïë            (ADMIN)               ‚ïë
‚ï†‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ï£
‚ïë üë• T·ªïng s·ªë ng∆∞·ªùi d√πng: {total_users:,}        ‚ïë
‚ïë üí∞ T·ªïng s·ªë d∆∞: {total_balance:,} VNƒê    ‚ïë
‚ïë üí∏ T·ªïng l·∫ßn r√∫t: {total_withdrawals:,}           ‚ïë
‚ïë üë®‚Äçüë©‚Äçüëß‚Äçüë¶ T·ªïng l∆∞·ª£t m·ªùi: {total_invites:,}          ‚ïë
‚ï†‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ï£
‚ïë üì¢ S·ªë nh√≥m/k√™nh: {channels_count}              ‚ïë
‚ïë üéÅ CODE th∆∞·ªùng: {codes_count}               ‚ïë
‚ïë üéÅ CODE ƒë·∫≠p h·ªôp: {drop_codes_count}             ‚ïë
‚ïë üîÑ CODE ƒë√£ d√πng: {used_codes_count}             ‚ïë
‚ïö‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïù
        """

        bot.send_message(message.chat.id, stats, parse_mode='HTML')
    else:
        # Th·ªëng k√™ cho USER - Ch·ªâ hi·ªán th√¥ng tin c√° nh√¢n
        # ƒê·∫£m b·∫£o user ƒë√£ ƒë∆∞·ª£c kh·ªüi t·∫°o
        if str(user_id) not in user_data:
            initialize_user(user_id)
        
        user_data_entry = user_data.get(str(user_id), {})
        balance = user_data_entry.get('balance', 0)
        withdrawals = user_data_entry.get('withdrawals', 0)
        invited_count = user_data_entry.get('invited_count', 0)
        
        # ƒê·∫øm s·ªë ng∆∞·ªùi ƒë∆∞·ª£c m·ªùi th√†nh c√¥ng
        successful_invites = len(get_referred_users(user_id))

        stats = f"""
‚ïî‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïó
‚ïë        üìä TH·ªêNG K√ä C√Å NH√ÇN        ‚ïë
‚ï†‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ï£
‚ïë üí∞ S·ªë d∆∞ hi·ªán t·∫°i: {balance:,} VNƒê      ‚ïë
‚ïë üí∏ S·ªë l·∫ßn r√∫t ti·ªÅn: {withdrawals:,}           ‚ïë
‚ïë üë• S·ªë l∆∞·ª£t m·ªùi: {invited_count:,}              ‚ïë
‚ïë ‚úÖ M·ªùi th√†nh c√¥ng: {successful_invites:,}           ‚ïë
‚ï†‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ï£
‚ïë üéØ M·ªùi th√™m b·∫°n b√® ƒë·ªÉ nh·∫≠n th∆∞·ªüng! ‚ïë
‚ïö‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïù
        """

        bot.send_message(message.chat.id, stats, parse_mode='HTML')

# Th√™m n√∫t c·ªông ti·ªÅn cho user
@bot.message_handler(func=lambda message: message.text == "üí∞ C·ªông ti·ªÅn")
def add_money_command(message):
    if message.from_user.id in admins:
        bot.send_message(
            message.chat.id,
            "Vui l√≤ng nh·∫≠p theo ƒë·ªãnh d·∫°ng: [ID ng∆∞·ªùi d√πng] [S·ªë ti·ªÅn]\nV√≠ d·ª•: 123456789 10000"
        )
        bot.register_next_step_handler(message, process_add_money)

def process_add_money(message):
    if message.from_user.id in admins:
        try:
            parts = message.text.strip().split()
            if len(parts) != 2:
                bot.send_message(
                    message.chat.id,
                    "ƒê·ªãnh d·∫°ng kh√¥ng ƒë√∫ng. Vui l√≤ng nh·∫≠p theo ƒë·ªãnh d·∫°ng: [ID ng∆∞·ªùi d√πng] [S·ªë ti·ªÅn]"
                )
                return

            user_id = parts[0]
            amount = int(parts[1])

            if amount <= 0:
                bot.send_message(message.chat.id, "S·ªë ti·ªÅn ph·∫£i l·ªõn h∆°n 0.")
                return

            update_user_balance(user_id, amount)
            current_balance = get_balance(user_id)

            bot.send_message(
                message.chat.id,
                f"‚úÖ ƒê√£ c·ªông {amount} VNƒê cho ng∆∞·ªùi d√πng {user_id}.\nS·ªë d∆∞ hi·ªán t·∫°i: {current_balance} VNƒê"
            )

            # Th√¥ng b√°o cho ng∆∞·ªùi d√πng
            try:
                bot.send_message(
                    user_id,
                    f"üí∞ T√†i kho·∫£n c·ªßa b·∫°n v·ª´a ƒë∆∞·ª£c c·ªông {amount} VNƒê.\nS·ªë d∆∞ hi·ªán t·∫°i: {current_balance} VNƒê"
                )
            except:
                bot.send_message(
                    message.chat.id,
                    "‚ö†Ô∏è Kh√¥ng th·ªÉ g·ª≠i th√¥ng b√°o ƒë·∫øn ng∆∞·ªùi d√πng n√†y.")

            # Quay l·∫°i menu admin
            admin_menu(message)
        except ValueError:
            bot.send_message(message.chat.id,
                             "Vui l√≤ng nh·∫≠p ƒë√∫ng ƒë·ªãnh d·∫°ng s·ªë.")
        except Exception as e:
            bot.send_message(message.chat.id, f"ƒê√£ x·∫£y ra l·ªói: {str(e)}")

@bot.message_handler(func=lambda message: message.text == "üë•M·ªúI B·∫†N B√à")
def handle_invite_friends(message):
    user_id = message.from_user.id
    invite_link = f"https://t.me/{bot.get_me().username}?start={user_id}"
    settings = load_settings()

    caption = f"""
üéÅ <b>M·ªúI B·∫†N B√à</b>

üîó <b>LINK GI·ªöI THI·ªÜU C·ª¶A B·∫†N:</b>
{invite_link}

üéÅ <b>TH∆Ø·ªûNG M·ªúI B·∫†N B√à:</b>
‚Ä¢ M·ªùi 1 b·∫°n = {settings['referral_bonus']}‚Ç´
‚Ä¢ T·ªëi thi·ªÉu ƒë·ªïi: {settings['min_withdraw']}‚Ç´

üì¢ <b>H∆Ø·ªöNG D·∫™N:</b>
‚Ä¢ G·ª≠i link cho b·∫°n b√®
‚Ä¢ B·∫°n b√® tham gia nh√≥m qua link
‚Ä¢ Nh·∫≠n th∆∞·ªüng ngay khi h·ªç tham gia
"""

    markup = types.InlineKeyboardMarkup(row_width=1)
    markup.add(
        types.InlineKeyboardButton("üìã SAO CH√âP LINK", callback_data=f"copy_link_{user_id}")
    )

    bot.send_message(message.chat.id,
                     caption,
                     reply_markup=markup,
                     parse_mode='HTML')

# Rest of ALL handlers and functions...
# [Include ALL remaining code from lines 1238-1857]

# X·ª≠ l√Ω l·ªánh /guimem t·ª´ admin
@bot.message_handler(commands=['chat'])
def handle_send_private_message(message):
    if message.from_user.id in admins:  # Ki·ªÉm tra xem c√≥ ph·∫£i admin kh√¥ng
        try:
            _, user_id_str, *message_text = message.text.split()
            if not message_text:
                bot.reply_to(message, "Vui l√≤ng cung c·∫•p n·ªôi dung tin nh·∫Øn.")
                return

            user_id = int(user_id_str)  # Ki·ªÉm tra user_id c√≥ h·ª£p l·ªá kh√¥ng
            message_to_send = ' '.join(message_text)
            send_private_message(user_id, message_to_send)
        except ValueError:
            bot.reply_to(
                message,
                "Vui l√≤ng s·ª≠ d·ª•ng l·ªánh theo ƒë·ªãnh d·∫°ng: /chat <user_id> <tin nh·∫Øn>"
            )
        except Exception as e:
            bot.reply_to(message, f"ƒê√£ x·∫£y ra l·ªói: {e}")
    else:
        bot.reply_to(message, "B·∫°n kh√¥ng c√≥ quy·ªÅn s·ª≠ d·ª•ng l·ªánh n√†y.")

@bot.message_handler(commands=['thongbaofull'])
def thongbao_text(message):
    if message.from_user.id in admins:
        try:
            parts = message.text.split(maxsplit=1)
            if len(parts) < 2:
                raise ValueError("Sai c√∫ ph√°p. D√πng: /thongbaofull [N·ªôi dung th√¥ng b√°o]")

            announcement = parts[1]
            success = 0
            fail = 0

            for user_id in user_data.keys():
                try:
                    bot.send_message(
                        user_id,
                        f"<b>üì¢ TH√îNG B√ÅO H·ªÜ TH·ªêNG</b>\n\n{announcement}",
                        parse_mode='HTML'
                    )
                    success += 1
                except Exception as e:
                    fail += 1
                    log_error(f"G·ª≠i cho user_id {user_id} th·∫•t b·∫°i: {str(e)}")

            bot.reply_to(
                message,
                f"ƒê√£ g·ª≠i th√¥ng b√°o ƒë·∫øn t·∫•t c·∫£ ng∆∞·ªùi d√πng!\nTh√†nh c√¥ng: {success}, Th·∫•t b·∫°i: {fail}"
            )

        except ValueError as e:
            bot.reply_to(message, str(e))

    else:
        bot.reply_to(message, "B·∫°n kh√¥ng c√≥ quy·ªÅn s·ª≠ d·ª•ng l·ªánh n√†y.")

@bot.message_handler(func=lambda message: message.text == "üë§T√ÄI KHO·∫¢N")
def handle_account_command(message):
    user_id = message.from_user.id
    username = message.from_user.username
    full_name = f"{message.from_user.first_name} {message.from_user.last_name}"
    balance = get_balance(user_id)
    balance_formatted = "{:,}".format(balance)

    text = f"""
‚ïî‚ïê‚ïê ‚ïê‚ïê ‚ïê‚ïê ‚ïê‚ïê ‚ïê‚ïê ‚ïê‚ïê ‚ïê‚ïê ‚ïê‚ïê
‚ïëüë§T√™n T√†i Kho·∫£n: `[{message.from_user.first_name} {message.from_user.last_name}]`
‚ïë
‚ïëüÜîID T√†i Kho·∫£n: `[{user_id}]`
‚ïë
‚ïëüí∞S·ªë D∆∞: `[{balance_formatted}]`ƒë
‚ïö‚ïê‚ïê ‚ïê‚ïê ‚ïê‚ïê ‚ïê‚ïê ‚ïê‚ïê ‚ïê‚ïê ‚ïê‚ïê ‚ïê‚ïê
"""

    bot.send_message(message.chat.id, text, parse_mode='Markdown')

@bot.message_handler(commands=['naptien'])
def handle_addcoin_command(message):
    user_id = message.from_user.id
    if user_id not in admins:
        bot.reply_to(message, "B·∫°n kh√¥ng c√≥ quy·ªÅn th·ª±c hi·ªán l·ªánh n√†y.")
        return

    try:
        details = message.text.split()
        target_user_id = int(details[1])
        amount = int(details[2])

        update_user_balance(target_user_id, amount)
        bot.reply_to(
            message,
            f'ƒê√£ c·ªông {amount} ƒë cho user {target_user_id}. S·ªë d∆∞ hi·ªán t·∫°i: {get_balance(target_user_id)} ƒë'
        )
    except (IndexError, ValueError):
        bot.reply_to(message,
                     'Vui l√≤ng nh·∫≠p theo c√∫ ph√°p /naptien[user_id] [s·ªë ti·ªÅn]')

#H√ÄM N·∫†P TR·ª™
@bot.message_handler(commands=['trutien'])
def handle_trucoin_command(message):
    user_id = message.from_user.id
    if user_id not in admins:
        bot.reply_to(message, "B·∫°n kh√¥ng c√≥ quy·ªÅn th·ª±c hi·ªán l·ªánh n√†y.")
        return

    try:
        # L·∫•y user_id v√† s·ªë ti·ªÅn t·ª´ tin nh·∫Øn
        details = message.text.split()
        target_user_id = int(details[1])
        amount = int(details[2])

        update_user_balance(target_user_id, -amount)
        bot.reply_to(
            message,
            f'ƒê√£ tr·ª´ {amount} coins c·ªßa user {target_user_id}. S·ªë d∆∞ hi·ªán t·∫°i: {get_balance(target_user_id)} coins'
        )
    except (IndexError, ValueError):
        bot.reply_to(
            message, 'Vui l√≤ng nh·∫≠p theo c√∫ ph√°p /trutien [user_id] [s·ªë ti·ªÅn]')

@bot.message_handler(func=lambda message: message.text == 'üéÅƒê·ªîI CODE')
def handle_exchange_code(message):
    user_id = message.from_user.id
    settings = load_settings()
    min_amount = settings['min_withdraw']

    # Ki·ªÉm tra n·∫øu ng∆∞·ªùi d√πng c√≥ t√†i kho·∫£n v√† s·ªë d∆∞ ƒë·ªß ƒë·ªÉ ƒë·ªïi code
    if str(user_id) in user_data:
        current_balance = user_data[str(user_id)].get('balance', 0)

        if current_balance >= min_amount:
            exchange_instructions = f"""

üÜò Vui L√≤ng Th·ª±c Hi·ªán Theo H∆∞·ªõng D·∫´n Sau:

/doicode [t√™n telegram] [s·ªë ti·ªÅn]

‚û°Ô∏è VD: /doicode @username 20000

‚ö†Ô∏è L∆∞u √Ω: 
- S·ªë ti·ªÅn ƒë·ªïi t·ªëi thi·ªÉu l√† {min_amount} VNƒê
- ‚ùåKh√¥ng h·ªó tr·ª£ ho√†n ti·ªÅn sau khi ƒë·ªïi CODE.
            """
            bot.send_message(message.chat.id, exchange_instructions)
        else:
            bot.send_message(
                message.chat.id,
                f"‚õîÔ∏è S·ªê D∆Ø KH√îNG ƒê·ª¶! B·∫°n c·∫ßn t·ªëi thi·ªÉu {min_amount} VNƒê ƒë·ªÉ ƒë·ªïi CODE. S·ªë d∆∞ hi·ªán t·∫°i: {current_balance} VNƒê"
            )
    else:
        bot.send_message(message.chat.id,
                         "‚õîÔ∏è B·∫†N CH∆ØA C√ì T√ÄI KHO·∫¢N HO·∫∂C S·ªê D∆Ø KH√îNG ƒê·ª¶!")

@bot.message_handler(commands=['doicode'])
def handle_code_exchange_request(message):
    user_id = message.from_user.id
    settings = load_settings()
    min_amount = settings['min_withdraw']

    if str(user_id) in user_data:
        current_balance = user_data[str(user_id)]['balance']
        details = message.text.split()

        if len(details) == 3:
            tele_username = details[1]
            amount = int(details[2])

            if amount >= min_amount:  # S·ªë ti·ªÅn t·ªëi thi·ªÉu ƒë·ªÉ ƒë·ªïi code
                if current_balance >= amount:
                    # Tr·ª´ s·ªë ti·ªÅn t·ª´ s·ªë d∆∞ c·ªßa ng∆∞·ªùi d√πng
                    user_data[str(user_id)]['balance'] -= amount
                    save_user_data(
                        user_data)  # L∆∞u l·∫°i d·ªØ li·ªáu sau khi c·∫≠p nh·∫≠t s·ªë d∆∞

                    # G·ª≠i th√¥ng b√°o cho ng∆∞·ªùi d√πng l√† ƒëang x·ª≠ l√Ω
                    bot.send_message(
                        message.chat.id,
                        f"‚è≥ <b>ƒêANG X·ª¨ L√ù Y√äU C·∫¶U ƒê·ªîI CODE</b>\n\n"
                        f"Y√™u c·∫ßu ƒë·ªïi CODE c·ªßa b·∫°n ƒëang ƒë∆∞·ª£c x·ª≠ l√Ω. Admin s·∫Ω x√°c nh·∫≠n s·ªõm.\n\n"
                        f"‚îè‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îì\n"
                        f"‚îÉüîéT√äN TELEGRAM: {tele_username}\n"
                        f"‚îÉüíµS·ªê TI·ªÄN: {amount} VNƒê\n"
                        f"‚îó‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îõ\n",
                        parse_mode='HTML')

                    if auto_approve:
                        # T·ª± ƒë·ªông duy·ªát v√† g·ª≠i code
                        code = get_random_code()
                        if code:
                            current_time = datetime.now().strftime(
                                "%d/%m/%Y %H:%M:%S")
                            username = f"User {user_id}"

                            used_codes[code] = {
                                'user_id': user_id,
                                'username': username,
                                'amount': amount,
                                'time': current_time
                            }
                            save_used_codes()

                            bot.send_message(
    user_id,
    f"üéâ <b>ƒê·ªîI CODE TH√ÄNH C√îNG</b>\n\n"
    f"Y√™u c·∫ßu ƒë·ªïi {amount} VNƒê c·ªßa b·∫°n ƒë√£ ƒë∆∞·ª£c duy·ªát t·ª± ƒë·ªông!\n\n"
    f"üí≥ CODE c·ªßa b·∫°n: <code>{code}</code>\n\n"
    f"C·∫£m ∆°n b·∫°n ƒë√£ s·ª≠ d·ª•ng d·ªãch v·ª• c·ªßa ch√∫ng t√¥i!",
    parse_mode='HTML'
)
                            # Th√¥ng b√°o cho admin
                            for admin_id in admins:
                                bot.send_message(
                                    admin_id, f"ü§ñ <b>DUY·ªÜT T·ª∞ ƒê·ªòNG</b>\n"
                                    f"ƒê√£ t·ª± ƒë·ªông duy·ªát y√™u c·∫ßu ƒë·ªïi CODE\n"
                                    f"üë§ User ID: {user_id}\n"
                                    f"üí∞ S·ªë ti·ªÅn: {amount} VNƒê\n"
                                    f"üéÅ CODE: <code>{code}</code>",
                                    parse_mode='HTML')
                        else:
                            # Kh√¥ng c√≤n code, ho√†n ti·ªÅn
                            update_user_balance(user_id, amount)
                            save_user_data(user_data)
                            bot.send_message(
                                user_id, "‚ùå <b>KH√îNG TH·ªÇ ƒê·ªîI CODE</b>\n\n"
                                f"H·ªá th·ªëng ƒëang h·∫øt CODE. S·ªë ti·ªÅn {amount} VNƒê ƒë√£ ƒë∆∞·ª£c ho√†n l·∫°i.\n"
                                "Vui l√≤ng th·ª≠ l·∫°i sau.",
                                parse_mode='HTML')
                    else:
                        # G·ª≠i y√™u c·∫ßu ƒë·ªïi code cho admin v·ªõi n√∫t ki·ªÉm tra
                        for admin_id in admins:
                            keyboard = types.InlineKeyboardMarkup(row_width=1)
                            keyboard.add(
                                types.InlineKeyboardButton(
                                    "üîç KI·ªÇM TRA NG∆Ø·ªúI ƒê√É ƒê∆Ø·ª¢C M·ªúI",
                                    callback_data=f"check_referred_{user_id}"),
                                types.InlineKeyboardButton(
                                    "‚úÖ DUY·ªÜT",
                                    callback_data=
                                    f"approve_code_{user_id}_{amount}"),
                                types.InlineKeyboardButton(
                                    "‚ùå T·ª™ CH·ªêI",
                                    callback_data=
                                    f"decline_code_{user_id}_{amount}"))

                        # Th√¥ng b√°o cho admin khi c√≥ ng∆∞·ªùi ƒë·ªïi code v√† t·∫Øt duy·ªát t·ª± ƒë·ªông
                        bot.send_message(
                            admin_id,
                            f"‚ÑπÔ∏è <b>TH√îNG B√ÅO</b>\nCh·∫ø ƒë·ªô duy·ªát t·ª± ƒë·ªông ƒëang T·∫ÆT\nVui l√≤ng xem x√©t y√™u c·∫ßu ƒë·ªïi code b√™n d∆∞·ªõi.",
                            parse_mode='HTML'
                        )
                        bot.send_message(
                            admin_id, f"üéÅ <b>Y√äU C·∫¶U ƒê·ªîI CODE</b>\n"
                            f"T·ª´: @{message.from_user.username}\n"
                            f"ID: <code>{user_id}</code>\n"
                            f"\nT√äN TELEGRAM: <code>{tele_username}</code>\n"
                            f"S·ªê TI·ªÄN: <code>{amount}</code> VNƒê",
                            reply_markup=keyboard,
                            parse_mode='HTML')

                else:
                    bot.send_message(message.chat.id,
                                     "‚õîÔ∏èS·ªê D∆Ø KH√îNG ƒê·ª¶ L·∫§Y G√å ƒê·ªîI CODE?")
            else:
                bot.send_message(
                    message.chat.id,
                    f"‚ö†Ô∏è S·ªë ti·ªÅn t·ªëi thi·ªÉu ƒë·ªÉ ƒë·ªïi CODE l√† {min_amount} VNƒê.")
        else:
            bot.send_message(
                message.chat.id,
                "üö´ Sai c√∫ ph√°p. Vui l√≤ng nh·∫≠p theo m·∫´u: `/doicode [t√™n telegram] [s·ªë ti·ªÅn]`"
            )
    else:
        bot.send_message(message.chat.id,
                         "üîí‚õîÔ∏èS·ªê D∆Ø KH√îNG ƒê·ª¶ L·∫§Y G√å ƒê·ªîI CODE?.")

# X·ª≠ l√Ω callback ki·ªÉm tra ng∆∞·ªùi ƒë∆∞·ª£c m·ªùi
@bot.callback_query_handler(
    func=lambda call: call.data.startswith('check_referred_'))
def handle_check_referred(call):
    if call.from_user.id in admins:
        user_id = call.data.split('_')[2]

        # L·∫•y danh s√°ch ng∆∞·ªùi ƒë∆∞·ª£c m·ªùi b·ªüi user n√†y
        referred_users = get_referred_users(user_id)

        if not referred_users:
            # T·∫°o keyboard ƒë·ªÉ quay l·∫°i
            keyboard = types.InlineKeyboardMarkup(row_width=1)
            keyboard.add(
                types.InlineKeyboardButton(
                    "üîô QUAY L·∫†I", callback_data=f"back_exchange_{user_id}"))

            bot.edit_message_text(
                f"<b>üîç TH√îNG TIN NG∆Ø·ªúI D√ôNG</b>\n\n"
                f"Ng∆∞·ªùi d√πng <code>{user_id}</code> ch∆∞a m·ªùi ƒë∆∞·ª£c ai.\n\n"
                f"Nh·∫•n n√∫t b√™n d∆∞·ªõi ƒë·ªÉ quay l·∫°i.",
                call.message.chat.id,
                call.message.message_id,
                reply_markup=keyboard,
                parse_mode='HTML')
        else:
            # T·∫°o keyboard ƒë·ªÉ quay l·∫°i
            keyboard = types.InlineKeyboardMarkup(row_width=1)
            keyboard.add(
                types.InlineKeyboardButton(
                    "üîô QUAY L·∫†I", callback_data=f"back_exchange_{user_id}"))

            # Format danh s√°ch ng∆∞·ªùi ƒë∆∞·ª£c m·ªùi
            user_list = ""
            for i, ref_user_id in enumerate(referred_users, 1):
                # C·ªë g·∫Øng l·∫•y th√¥ng tin username n·∫øu c√≥
                try:
                    # Kh√¥ng d√πng API get_chat v√¨ d·ªÖ g√¢y l·ªói n·∫øu ng∆∞·ªùi d√πng ch·∫∑n bot
                    username_ref = "Kh√¥ng x√°c ƒë·ªãnh"
                    username = f"ID: {ref_user_id}"
                    user_list += f"{i}. {username}\n"
                except:
                    user_list += f"{i}. ID: {ref_user_id}\n"

            bot.edit_message_text(
                f"<b>üîç DANH S√ÅCH NG∆Ø·ªúI ƒê∆Ø·ª¢C M·ªúI</b>\n\n"
                f"Ng∆∞·ªùi d√πng <code>{user_id}</code> ƒë√£ m·ªùi {len(referred_users)} ng∆∞·ªùi:\n\n"
                f"{user_list}\n"
                f"Nh·∫•n n√∫t b√™n d∆∞·ªõi ƒë·ªÉ quay l·∫°i.",
                call.message.chat.id,
                call.message.message_id,
                reply_markup=keyboard,
                parse_mode='HTML')

# NEW: Handler for approve code button
@bot.callback_query_handler(func=lambda call: call.data.startswith('approve_code_'))
def handle_approve_code(call):
    if call.from_user.id in admins:
        try:
            # Parse callback data: approve_code_{user_id}_{amount}
            parts = call.data.split('_')
            user_id = int(parts[2])
            amount = int(parts[3])
            
            # Get random code
            code = get_random_code()
            if code:
                # Update user balance (already deducted in doicode handler)
                current_time = datetime.now().strftime("%d/%m/%Y %H:%M:%S")
                username = f"User {user_id}"
                
                # Save used code info
                used_codes[code] = {
                    'user_id': user_id,
                    'username': username,
                    'amount': amount,
                    'time': current_time
                }
                save_used_codes()
                
                # TƒÉng counter s·ªë l·∫ßn r√∫t ti·ªÅn
                user_id_str = str(user_id)
                if user_id_str in user_data:
                    if 'withdrawals' not in user_data[user_id_str]:
                        user_data[user_id_str]['withdrawals'] = 0
                    user_data[user_id_str]['withdrawals'] += 1
                    save_data(user_data_file, user_data)
                
                # Send code to user
                bot.send_message(
                    user_id,
                    f"üéâ <b>ƒê·ªîI CODE TH√ÄNH C√îNG</b>\n\n"
                    f"Y√™u c·∫ßu ƒë·ªïi {amount} VNƒê c·ªßa b·∫°n ƒë√£ ƒë∆∞·ª£c duy·ªát!\n\n"
                    f"üí≥ CODE c·ªßa b·∫°n: <code>{code}</code>\n\n"
                    f"C·∫£m ∆°n b·∫°n ƒë√£ s·ª≠ d·ª•ng d·ªãch v·ª• c·ªßa ch√∫ng t√¥i!",
                    parse_mode='HTML'
                )
                
                # Notify admin
                bot.edit_message_text(
                    f"‚úÖ <b>ƒê√É DUY·ªÜT Y√äU C·∫¶U ƒê·ªîI CODE</b>\n\n"
                    f"üë§ User ID: {user_id}\n"
                    f"üí∞ S·ªë ti·ªÅn: {amount} VNƒê\n"
                    f"üéÅ CODE: <code>{code}</code>\n"
                    f"‚è∞ Th·ªùi gian: {current_time}",
                    call.message.chat.id,
                    call.message.message_id,
                    parse_mode='HTML'
                )
                
                # Log the approval
                log_debug(f"Admin {call.from_user.id} approved code exchange for user {user_id}, amount: {amount}, code: {code}")
                
            else:
                # No codes available, refund user
                update_user_balance(user_id, amount)
                save_user_data(user_data)
                
                bot.send_message(
                    user_id,
                    "‚ùå <b>KH√îNG TH·ªÇ ƒê·ªîI CODE</b>\n\n"
                    f"H·ªá th·ªëng ƒëang h·∫øt CODE. S·ªë ti·ªÅn {amount} VNƒê ƒë√£ ƒë∆∞·ª£c ho√†n l·∫°i.\n"
                    "Vui l√≤ng th·ª≠ l·∫°i sau.",
                    parse_mode='HTML'
                )
                
                bot.edit_message_text(
                    f"‚ùå <b>KH√îNG TH·ªÇ DUY·ªÜT</b>\n\n"
                    f"üë§ User ID: {user_id}\n"
                    f"üí∞ S·ªë ti·ªÅn: {amount} VNƒê\n"
                    f"‚ö†Ô∏è L√Ω do: H·∫øt CODE trong h·ªá th·ªëng\n"
                    f"üí∏ ƒê√£ ho√†n ti·ªÅn cho ng∆∞·ªùi d√πng",
                    call.message.chat.id,
                    call.message.message_id,
                    parse_mode='HTML'
                )
                
        except Exception as e:
            log_error(f"Error in handle_approve_code: {e}")
            bot.answer_callback_query(call.id, "‚ùå C√≥ l·ªói x·∫£y ra khi duy·ªát code!")
    else:
        bot.answer_callback_query(call.id, "‚ùå B·∫°n kh√¥ng c√≥ quy·ªÅn th·ª±c hi·ªán h√†nh ƒë·ªông n√†y!")

# NEW: Handler for decline code button
@bot.callback_query_handler(func=lambda call: call.data.startswith('decline_code_'))
def handle_decline_code(call):
    if call.from_user.id in admins:
        try:
            # Parse callback data: decline_code_{user_id}_{amount}
            parts = call.data.split('_')
            user_id = int(parts[2])
            amount = int(parts[3])
            
            # Refund user
            update_user_balance(user_id, amount)
            save_user_data(user_data)
            
            # Notify user
            bot.send_message(
                user_id,
                f"‚ùå <b>Y√äU C·∫¶U ƒê·ªîI CODE B·ªä T·ª™ CH·ªêI</b>\n\n"
                f"Y√™u c·∫ßu ƒë·ªïi {amount} VNƒê c·ªßa b·∫°n ƒë√£ b·ªã t·ª´ ch·ªëi.\n"
                f"üí∞ S·ªë ti·ªÅn {amount} VNƒê ƒë√£ ƒë∆∞·ª£c ho√†n l·∫°i v√†o t√†i kho·∫£n.\n\n"
                f"Vui l√≤ng li√™n h·ªá admin ƒë·ªÉ bi·∫øt th√™m chi ti·∫øt.",
                parse_mode='HTML'
            )
            
            # Notify admin
            bot.edit_message_text(
                f"‚ùå <b>ƒê√É T·ª™ CH·ªêI Y√äU C·∫¶U ƒê·ªîI CODE</b>\n\n"
                f"üë§ User ID: {user_id}\n"
                f"üí∞ S·ªë ti·ªÅn: {amount} VNƒê\n"
                f"üí∏ ƒê√£ ho√†n ti·ªÅn cho ng∆∞·ªùi d√πng\n"
                f"‚è∞ Th·ªùi gian: {datetime.now().strftime('%d/%m/%Y %H:%M:%S')}",
                call.message.chat.id,
                call.message.message_id,
                parse_mode='HTML'
            )
            
            # Log the decline
            log_debug(f"Admin {call.from_user.id} declined code exchange for user {user_id}, amount: {amount}")
            
        except Exception as e:
            log_error(f"Error in handle_decline_code: {e}")
            bot.answer_callback_query(call.id, "‚ùå C√≥ l·ªói x·∫£y ra khi t·ª´ ch·ªëi code!")
    else:
        bot.answer_callback_query(call.id, "‚ùå B·∫°n kh√¥ng c√≥ quy·ªÅn th·ª±c hi·ªán h√†nh ƒë·ªông n√†y!")

@bot.message_handler(func=lambda message: message.text == "üñº Thay ƒë·ªïi ·∫£nh th√¥ng b√°o")
def change_announcement_image(message):
    if message.from_user.id in admins:
        markup = types.ReplyKeyboardMarkup(row_width=1, resize_keyboard=True)
        markup.add(types.KeyboardButton('üîô Quay l·∫°i menu admin'))

        bot.send_message(
            message.chat.id, 
            "üì§ Vui l√≤ng g·ª≠i ·∫£nh m·ªõi cho th√¥ng b√°o tham gia nh√≥m:",
            reply_markup=markup
        )
        bot.register_next_step_handler(message, process_new_image)

def process_new_image(message):
    if message.from_user.id in admins:
        if message.text == 'üîô Quay l·∫°i menu admin':
            admin_menu(message)
            return

        try:
            if message.photo:
                # L·∫•y file_id c·ªßa ·∫£nh c√≥ ƒë·ªô ph√¢n gi·∫£i cao nh·∫•t
                file_id = message.photo[-1].file_id
                # L∆∞u file_id v√†o settings
                settings = load_settings()
                settings['announcement_image'] = file_id
                save_settings(settings)

                bot.reply_to(message, "‚úÖ ƒê√£ c·∫≠p nh·∫≠t ·∫£nh th√¥ng b√°o th√†nh c√¥ng!")
                admin_menu(message)  # Quay l·∫°i menu admin
            else:
                bot.reply_to(message, "‚ùå Vui l√≤ng g·ª≠i m·ªôt ·∫£nh!")
                bot.register_next_step_handler(message, process_new_image)  # Ti·∫øp t·ª•c ch·ªù ·∫£nh
        except Exception as e:
            bot.reply_to(message, f"‚úÖ G·ª≠i ·∫£nh th√†nh c√¥ng !: {str(e)}")
            admin_menu(message)

@bot.callback_query_handler(func=lambda call: call.data.startswith('copy_link_'))
def handle_copy_link(call):
    user_id = call.data.split('_')[2]
    invite_link = f"https://t.me/{bot.get_me().username}?start={user_id}"
    
    bot.answer_callback_query(
        call.id,
        text="‚úÖ ƒê√£ sao ch√©p link gi·ªõi thi·ªáu!",
        show_alert=True
    )

# [Continue with ALL remaining handlers...]

@bot.message_handler(func=lambda message: message.text == "üéÆLINK GAME")
def handle_game_link(message):
    user_id = message.from_user.id

    # N·∫øu c√≥ k√™nh y√™u c·∫ßu v√† ng∆∞·ªùi d√πng ch∆∞a tham gia ‚Üí ƒëi·ªÅu h∆∞·ªõng v·ªÅ m√†n h√¨nh tham gia
    channels = load_channels()
    if channels and not check_subscription_with_retry(user_id):
        join_markup = types.InlineKeyboardMarkup(row_width=1)
        for ch in channels:
            if isinstance(ch, dict):
                username = ch.get("username", "").lstrip('@').strip()
                title = ch.get("title", ch.get("username", "")).strip()
            else:
                username = str(ch).lstrip('@').strip()
                title = f"üîó @{username}"
            if username:
                url = f"https://t.me/{username}"
                join_markup.add(types.InlineKeyboardButton(title, url=url))
        join_markup.add(types.InlineKeyboardButton('‚úÖ X√ÅC MINH THAM GIA', callback_data='check'))

        bot.send_message(
            message.chat.id,
            "‚ùóÔ∏èB·∫°n c·∫ßn tham gia ƒë·ªß k√™nh tr∆∞·ªõc khi d√πng t√≠nh nƒÉng n√†y.\nVui l√≤ng tham gia v√† b·∫•m \"‚úÖ X√ÅC MINH THAM GIA\".",
            reply_markup=join_markup
        )
        return

    current_link = load_game_link()
    
    if current_link:
        caption = f"""
üéÆ <b>LINK GAME CH√çNH TH·ª®C</b>

üîó <b>Link game:</b> {current_link}

üì± <b>H∆∞·ªõng d·∫´n:</b>
‚Ä¢ Nh·∫•n v√†o link ƒë·ªÉ ch∆°i game
‚Ä¢ Nh·∫≠p code ·ªü ph·∫ßn n·∫°p ti·ªÅn 
‚Ä¢ Li√™n h·ªá admin n·∫øu c√≥ v·∫•n ƒë·ªÅ

üéÅ <b>Ch√∫c b·∫°n ch∆°i game vui v·∫ª!</b>
"""
        markup = types.InlineKeyboardMarkup(row_width=1)
        markup.add(types.InlineKeyboardButton("üéÆ CH∆†I NGAY", url=current_link))
        
        bot.send_message(message.chat.id, caption, reply_markup=markup, parse_mode='HTML')
    else:
        bot.send_message(message.chat.id, "‚ùå Link game ch∆∞a ƒë∆∞·ª£c c·∫≠p nh·∫≠t. Vui l√≤ng li√™n h·ªá admin.")

# [All remaining code through line 1857 should be included here...]


# =========================
# GROUP MANAGEMENT HANDLERS
# =========================

@bot.message_handler(func=lambda message: message.text == "‚ûï Th√™m nh√≥m")
def handle_add_channel(message):
    if message.from_user.id in admins:
        markup = types.ReplyKeyboardMarkup(row_width=2, resize_keyboard=True)
        markup.add(types.KeyboardButton('‚ûï Th√™m 1 nh√≥m'),
                   types.KeyboardButton('üìù Th√™m nhi·ªÅu nh√≥m'))
        markup.add(types.KeyboardButton('üîô Quay l·∫°i menu qu·∫£n l√Ω nh√≥m'))
        
        bot.send_message(
            message.chat.id, 
            "üìå <b>Ch·ªçn c√°ch th√™m nh√≥m:</b>\n\n"
            "‚ûï <b>Th√™m 1 nh√≥m:</b> Th√™m t·ª´ng nh√≥m m·ªôt\n"
            "üìù <b>Th√™m nhi·ªÅu nh√≥m:</b> Th√™m nhi·ªÅu nh√≥m c√πng l√∫c b·∫±ng @",
            reply_markup=markup,
            parse_mode='HTML'
        )

@bot.message_handler(func=lambda message: message.text == "‚ûï Th√™m 1 nh√≥m")
def handle_add_single_channel(message):
    if message.from_user.id in admins:
        bot.send_message(
            message.chat.id, 
            "üìå Vui l√≤ng nh·∫≠p **Username** (b·∫Øt ƒë·∫ßu b·∫±ng @) ho·∫∑c **ID s·ªë** c·ªßa nh√≥m/k√™nh b·∫°n mu·ªën th√™m:",
            parse_mode='Markdown'
        )
        bot.register_next_step_handler(message, process_add_channel)

def process_add_channel(message):
    if message.from_user.id in admins:
        try:
            channel_input = message.text.strip().lstrip('@')

            access_result = verify_bot_access(channel_input)
            if not access_result['has_access']:
                bot.send_message(
                    message.chat.id, 
                    f"‚ùå Bot kh√¥ng c√≥ quy·ªÅn trong nh√≥m/k√™nh <code>@{channel_input}</code>. Vui l√≤ng th√™m bot l√†m admin!",
                    parse_mode='HTML'
                )
                channel_management_menu(message)
                return

            chat_info = bot.get_chat(channel_input if channel_input.lstrip('-').isdigit() else f'@{channel_input}')
            username = chat_info.username or str(chat_info.id)
            title = chat_info.title or f"Nh√≥m/K√™nh ({chat_info.id})"

            channels = load_channels()
            if any(c.get('username') == username for c in channels if isinstance(c, dict)):
                bot.send_message(
                    message.chat.id, 
                    f"‚ùå Nh√≥m/k√™nh <code>@{username}</code> ƒë√£ t·ªìn t·∫°i.",
                    parse_mode='HTML'
                )
                channel_management_menu(message)
                return

            new_channel = {'username': username, 'title': title}
            channels.append(new_channel)
            save_channels(channels)

            bot.send_message(
                message.chat.id, 
                f"‚úÖ ƒê√£ th√™m th√†nh c√¥ng:\n‚Ä¢ <b>Username:</b> <code>@{username}</code>\n‚Ä¢ <b>Title:</b> {title}",
                parse_mode='HTML'
            )
            channel_management_menu(message)

        except Exception as e:
            log_error(f"Error adding channel: {e}")
            bot.send_message(message.chat.id, f"‚ùå ƒê√£ x·∫£y ra l·ªói khi th√™m nh√≥m/k√™nh: {str(e)}")
            channel_management_menu(message)

@bot.message_handler(func=lambda message: message.text == "üìù Th√™m nhi·ªÅu nh√≥m")
def handle_add_multiple_channels(message):
    if message.from_user.id in admins:
        bot.send_message(
            message.chat.id, 
            "üìù <b>TH√äM NHI·ªÄU NH√ìM C√ôNG L√öC</b>\n\n"
            "üìå <b>C√°ch s·ª≠ d·ª•ng:</b>\n"
            "‚Ä¢ Nh·∫≠p danh s√°ch c√°c nh√≥m/k√™nh, m·ªói d√≤ng m·ªôt nh√≥m\n"
            "‚Ä¢ C√≥ th·ªÉ d√πng @username ho·∫∑c ID s·ªë\n"
            "‚Ä¢ V√≠ d·ª•:\n"
            "<code>@group1\n@group2\n@channel1\n-1001234567890</code>\n\n"
            "üì§ <b>G·ª≠i danh s√°ch nh√≥m b·∫°n mu·ªën th√™m:</b>",
            parse_mode='HTML'
        )
        bot.register_next_step_handler(message, process_add_multiple_channels)

def process_add_multiple_channels(message):
    if message.from_user.id in admins:
        try:
            # Parse the input - split by lines and clean up
            lines = message.text.strip().split('\n')
            channel_inputs = []
            
            for line in lines:
                line = line.strip()
                if line:  # Skip empty lines
                    # Remove @ prefix if present
                    clean_line = line.lstrip('@')
                    if clean_line:  # Only add non-empty cleaned lines
                        channel_inputs.append(clean_line)
            
            if not channel_inputs:
                bot.send_message(
                    message.chat.id, 
                    "‚ùå Kh√¥ng t√¨m th·∫•y nh√≥m/k√™nh n√†o trong danh s√°ch. Vui l√≤ng th·ª≠ l·∫°i.",
                    parse_mode='HTML'
                )
                channel_management_menu(message)
                return
            
            bot.send_message(
                message.chat.id, 
                f"‚è≥ ƒêang x·ª≠ l√Ω {len(channel_inputs)} nh√≥m/k√™nh...",
                parse_mode='HTML'
            )
            
            channels = load_channels()
            added_channels = []
            failed_channels = []
            duplicate_channels = []
            
            for channel_input in channel_inputs:
                try:
                    # Check bot access first
                    access_result = verify_bot_access(channel_input)
                    if not access_result['has_access']:
                        failed_channels.append(f"@{channel_input} - Bot kh√¥ng c√≥ quy·ªÅn")
                        continue
                    
                    # Get chat info
                    chat_info = bot.get_chat(channel_input if channel_input.lstrip('-').isdigit() else f'@{channel_input}')
                    username = chat_info.username or str(chat_info.id)
                    title = chat_info.title or f"Nh√≥m/K√™nh ({chat_info.id})"
                    
                    # Check for duplicates
                    if any(c.get('username') == username for c in channels if isinstance(c, dict)):
                        duplicate_channels.append(f"@{username} - {title}")
                        continue
                    
                    # Add the channel
                    new_channel = {'username': username, 'title': title}
                    channels.append(new_channel)
                    added_channels.append(f"@{username} - {title}")
                    
                except Exception as e:
                    failed_channels.append(f"@{channel_input} - L·ªói: {str(e)}")
                    log_error(f"Error processing channel {channel_input}: {e}")
            
            # Save all channels at once
            save_channels(channels)
            
            # Prepare response
            response = f"üìä <b>K·∫æT QU·∫¢ TH√äM NH√ìM</b>\n\n"
            
            if added_channels:
                response += f"‚úÖ <b>ƒê√£ th√™m th√†nh c√¥ng ({len(added_channels)} nh√≥m):</b>\n"
                for channel in added_channels:
                    response += f"‚Ä¢ {channel}\n"
                response += "\n"
            
            if duplicate_channels:
                response += f"‚ö†Ô∏è <b>ƒê√£ t·ªìn t·∫°i ({len(duplicate_channels)} nh√≥m):</b>\n"
                for channel in duplicate_channels:
                    response += f"‚Ä¢ {channel}\n"
                response += "\n"
            
            if failed_channels:
                response += f"‚ùå <b>Th·∫•t b·∫°i ({len(failed_channels)} nh√≥m):</b>\n"
                for channel in failed_channels:
                    response += f"‚Ä¢ {channel}\n"
            
            bot.send_message(message.chat.id, response, parse_mode='HTML')
            channel_management_menu(message)
            
        except Exception as e:
            log_error(f"Error in process_add_multiple_channels: {e}")
            bot.send_message(
                message.chat.id, 
                f"‚ùå ƒê√£ x·∫£y ra l·ªói khi x·ª≠ l√Ω danh s√°ch nh√≥m: {str(e)}",
                parse_mode='HTML'
            )
            channel_management_menu(message)


@bot.message_handler(func=lambda message: message.text == "‚ûñ X√≥a nh√≥m")
def handle_remove_channel(message):
    if message.from_user.id in admins:
        channels = load_channels()
        if not channels:
            bot.send_message(message.chat.id, "‚ùå Danh s√°ch nh√≥m/k√™nh tr·ªëng.")
            channel_management_menu(message)
            return

        text = "üóë **Ch·ªçn nh√≥m/k√™nh b·∫°n mu·ªën x√≥a (nh·∫≠p s·ªë th·ª© t·ª±):**\n\n"
        markup = types.ReplyKeyboardMarkup(row_width=2, resize_keyboard=True, one_time_keyboard=True)
        options = []

        for i, channel in enumerate(channels, 1):
            if isinstance(channel, dict):
                username = channel.get('username', 'Kh√¥ng x√°c ƒë·ªãnh')
                title = channel.get('title', username)
                text += f"{i}. <code>@{username}</code> - {title}\n"
            else:
                username = str(channel).lstrip('@')
                text += f"{i}. <code>@{username}</code>\n"
            options.append(str(i))

        for i in range(0, len(options), 4):
            markup.add(*[types.KeyboardButton(btn) for btn in options[i:i+4]])
        markup.add(types.KeyboardButton('üîô Quay l·∫°i menu qu·∫£n l√Ω nh√≥m'))

        bot.send_message(message.chat.id, text, reply_markup=markup, parse_mode='HTML')
        bot.register_next_step_handler(message, process_remove_channel)

def process_remove_channel(message):
    if message.from_user.id in admins:
        if message.text == 'üîô Quay l·∫°i menu qu·∫£n l√Ω nh√≥m':
            channel_management_menu(message)
            return
        try:
            index = int(message.text.strip()) - 1
            channels = load_channels()
            if 0 <= index < len(channels):
                removed = channels.pop(index)
                save_channels(channels)
                removed_name = removed.get('username') if isinstance(removed, dict) else str(removed)
                bot.send_message(message.chat.id, f"‚úÖ ƒê√£ x√≥a <code>@{removed_name}</code>", parse_mode='HTML')
            else:
                bot.send_message(message.chat.id, "‚ùå S·ªë th·ª© t·ª± kh√¥ng h·ª£p l·ªá.")
            channel_management_menu(message)
        except ValueError:
            bot.send_message(message.chat.id, "‚ùå Vui l√≤ng nh·∫≠p s·ªë th·ª© t·ª± h·ª£p l·ªá.")
            channel_management_menu(message)


@bot.message_handler(func=lambda message: message.text == "‚úèÔ∏è ƒê·ªïi T√™n Nh√≥m")
def handle_rename_channel(message):
    if message.from_user.id in admins:
        channels = load_channels()
        if not channels:
            bot.send_message(message.chat.id, "‚ùå Danh s√°ch nh√≥m/k√™nh tr·ªëng.")
            channel_management_menu(message)
            return

        text = "‚úèÔ∏è <b>Ch·ªçn nh√≥m/k√™nh mu·ªën ƒë·ªïi t√™n (nh·∫≠p s·ªë th·ª© t·ª±):</b>\n\n"
        markup = types.ReplyKeyboardMarkup(row_width=4, resize_keyboard=True, one_time_keyboard=True)
        options = []

        for i, channel in enumerate(channels, 1):
            if isinstance(channel, dict):
                username = channel.get('username', '')
                title = channel.get('title', username)
                text += f"{i}. <code>@{username or channel.get('id','?')}</code> - Hi·ªán t·∫°i: {title}\n"
            else:
                username = str(channel).lstrip('@')
                text += f"{i}. <code>@{username}</code> - Hi·ªán t·∫°i: @{username}\n"
            options.append(str(i))

        for i in range(0, len(options), 4):
            markup.add(*[types.KeyboardButton(btn) for btn in options[i:i+4]])
        markup.add(types.KeyboardButton('üîô Quay l·∫°i menu qu·∫£n l√Ω nh√≥m'))

        bot.send_message(message.chat.id, text, reply_markup=markup, parse_mode='HTML')
        bot.register_next_step_handler(message, process_select_channel_to_rename)

def process_select_channel_to_rename(message):
    if message.from_user.id in admins:
        if message.text == 'üîô Quay l·∫°i menu qu·∫£n l√Ω nh√≥m':
            channel_management_menu(message)
            return
        try:
            index = int(message.text.strip()) - 1
            channels = load_channels()
            if 0 <= index < len(channels):
                user_data.setdefault(str(message.from_user.id), {})['rename_channel_index'] = index
                save_user_data(user_data)
                current_channel = channels[index]
                current_title = current_channel.get('title') if isinstance(current_channel, dict) else str(current_channel)
                bot.send_message(message.chat.id, f"‚úèÔ∏è Nh·∫≠p t√™n hi·ªÉn th·ªã m·ªõi cho k√™nh: <b>{current_title}</b>", parse_mode='HTML')
                bot.register_next_step_handler(message, process_rename_channel)
            else:
                bot.send_message(message.chat.id, "‚ùå S·ªë th·ª© t·ª± kh√¥ng h·ª£p l·ªá.")
                channel_management_menu(message)
        except ValueError:
            bot.send_message(message.chat.id, "‚ùå Vui l√≤ng nh·∫≠p s·ªë h·ª£p l·ªá.")
            channel_management_menu(message)

def process_rename_channel(message):
    if message.from_user.id in admins:
        new_title = message.text.strip()
        user_id_str = str(message.from_user.id)
        index = user_data.get(user_id_str, {}).get('rename_channel_index')
        channels = load_channels()
        if index is not None and 0 <= index < len(channels):
            if not isinstance(channels[index], dict):
                username = str(channels[index]).lstrip('@')
                channels[index] = {'username': username, 'title': username}
            channels[index]['title'] = new_title
            save_channels(channels)
            user_data[user_id_str].pop('rename_channel_index', None)
            save_user_data(user_data)
            bot.send_message(message.chat.id, f"‚úÖ ƒê√£ ƒë·ªïi t√™n th√†nh c√¥ng: <b>{new_title}</b>", parse_mode='HTML')
        else:
            bot.send_message(message.chat.id, "‚ùå Kh√¥ng t√¨m th·∫•y nh√≥m c·∫ßn ƒë·ªïi t√™n.")
        channel_management_menu(message)


@bot.message_handler(func=lambda message: message.text == "üîç Ki·ªÉm tra quy·ªÅn admin")
def handle_check_admin(message):
    if message.from_user.id in admins:
        try:
            permissions = check_bot_permissions()
            response = "üîç <b>TR·∫†NG TH√ÅI QUY·ªÄN BOT</b>\n\n"
            
            if not permissions:
                response += "‚ùå Kh√¥ng c√≥ nh√≥m/k√™nh n√†o ƒë∆∞·ª£c c·∫•u h√¨nh.\n"
            else:
                success_count = 0
                for perm in permissions:
                    if perm.get('success', False):
                        success_count += 1
                        response += (f"‚úÖ <b>{perm['channel']}</b>\n"
                                     f"   ‚Ä¢ Tr·∫°ng th√°i: {perm['bot_status']}\n"
                                     f"   ‚Ä¢ Lo·∫°i: {perm['chat_type']}\n"
                                     f"   ‚Ä¢ T√™n: {perm.get('chat_title', 'N/A')}\n\n")
                    else:
                        response += (f"‚ùå <b>{perm['channel']}</b>\n"
                                     f"   ‚Ä¢ L·ªói: {perm.get('error', 'Kh√¥ng x√°c ƒë·ªãnh')}\n\n")
                
                response += f"üìä <b>T·ªïng k·∫øt:</b> {success_count}/{len(permissions)} nh√≥m/k√™nh ho·∫°t ƒë·ªông t·ªët\n"
            
            markup = types.ReplyKeyboardMarkup(row_width=1, resize_keyboard=True)
            markup.add(types.KeyboardButton('üîô Quay l·∫°i menu qu·∫£n l√Ω nh√≥m'))
            bot.send_message(message.chat.id, response.strip(), reply_markup=markup, parse_mode='HTML')
            
        except Exception as e:
            bot.send_message(message.chat.id, f"‚ùå L·ªói khi ki·ªÉm tra quy·ªÅn: {str(e)}")
    else:
        bot.reply_to(message, "‚ùå B·∫°n kh√¥ng c√≥ quy·ªÅn s·ª≠ d·ª•ng ch·ª©c nƒÉng n√†y!")



# =========================================================
# NEW: HANDLERS QUAY L·∫†I MENU ADMIN & SUB-MENUS (FIX L·ªñI 1)
# =========================================================

@bot.message_handler(func=lambda message: message.text == "üîô Quay l·∫°i menu qu·∫£n l√Ω nh√≥m")
def back_to_channel_management_menu(message):
    if message.from_user.id in admins:
        bot.send_message(message.chat.id, "üìå ƒê√£ quay l·∫°i menu qu·∫£n l√Ω nh√≥m.")
        channel_management_menu(message)
    else:
        bot.reply_to(message, "‚ùå B·∫°n kh√¥ng c√≥ quy·ªÅn truy c·∫≠p ch·ª©c nƒÉng n√†y!")

@bot.message_handler(func=lambda message: message.text == "üîô Quay l·∫°i menu admin")
def back_to_admin_menu(message):
    if message.from_user.id in admins:
        admin_menu(message)
    else:
        bot.reply_to(message, "‚ùå B·∫°n kh√¥ng c√≥ quy·ªÅn truy c·∫≠p ch·ª©c nƒÉng n√†y!")

@bot.message_handler(func=lambda message: message.text == "üéÆ Qu·∫£n l√Ω Link Game")
def handle_game_link_management(message):
    if message.from_user.id in admins:
        current_link = load_game_link()
        markup = types.ReplyKeyboardMarkup(row_width=2, resize_keyboard=True)
        markup.add(types.KeyboardButton('‚úèÔ∏è S·ª≠a Link Game'),
                   types.KeyboardButton('üëÅ Xem Link Game'))
        markup.add(types.KeyboardButton('üîô Quay l·∫°i menu admin'))
        
        status_text = f"Link hi·ªán t·∫°i: {current_link if current_link else 'Ch∆∞a c√≥ link'}"
        
        bot.send_message(
            message.chat.id,
            f"üéÆ <b>Qu·∫£n l√Ω Link Game</b>\n\n{status_text}\n\nCh·ªçn ch·ª©c nƒÉng:",
            reply_markup=markup,
            parse_mode='HTML'
        )
    else:
        bot.reply_to(message, "‚ùå B·∫°n kh√¥ng c√≥ quy·ªÅn truy c·∫≠p ch·ª©c nƒÉng n√†y!")

@bot.message_handler(func=lambda message: message.text == "‚úèÔ∏è S·ª≠a Link Game")
def handle_edit_game_link(message):
    if message.from_user.id in admins:
        bot.send_message(
            message.chat.id,
            "üìù <b>S·ª¨A LINK GAME</b>\n\nVui l√≤ng nh·∫≠p link game m·ªõi:",
            parse_mode='HTML'
        )
        bot.register_next_step_handler(message, process_edit_game_link)
    else:
        bot.reply_to(message, "‚ùå B·∫°n kh√¥ng c√≥ quy·ªÅn truy c·∫≠p ch·ª©c nƒÉng n√†y!")

def process_edit_game_link(message):
    if message.from_user.id in admins:
        new_link = message.text.strip()
        
        # Ki·ªÉm tra link c√≥ h·ª£p l·ªá kh√¥ng
        if new_link.startswith(('http://', 'https://')):
            save_game_link(new_link)
            global game_link
            game_link = new_link
            
            bot.send_message(
                message.chat.id,
                f"‚úÖ <b>ƒê√É C·∫¨P NH·∫¨T LINK GAME</b>\n\nLink m·ªõi: {new_link}",
                parse_mode='HTML'
            )
        else:
            bot.send_message(
                message.chat.id,
                "‚ùå Link kh√¥ng h·ª£p l·ªá! Vui l√≤ng nh·∫≠p link b·∫Øt ƒë·∫ßu b·∫±ng http:// ho·∫∑c https://"
            )
            bot.register_next_step_handler(message, process_edit_game_link)
            return
        
        # Quay l·∫°i menu qu·∫£n l√Ω link game
        handle_game_link_management(message)

@bot.message_handler(func=lambda message: message.text == "üëÅ Xem Link Game")
def handle_view_game_link(message):
    if message.from_user.id in admins:
        current_link = load_game_link()
        
        if current_link:
            response = f"""
üéÆ <b>LINK GAME HI·ªÜN T·∫†I</b>

üîó <b>Link:</b> {current_link}

üìä <b>Th·ªëng k√™:</b>
‚Ä¢ Link ƒë√£ ƒë∆∞·ª£c c·∫≠p nh·∫≠t
‚Ä¢ User c√≥ th·ªÉ truy c·∫≠p qua menu ch√≠nh
"""
            markup = types.InlineKeyboardMarkup(row_width=1)
            markup.add(types.InlineKeyboardButton("üîó M·ªü Link", url=current_link))
            
            bot.send_message(message.chat.id, response, reply_markup=markup, parse_mode='HTML')
        else:
            bot.send_message(message.chat.id, "‚ùå Ch∆∞a c√≥ link game n√†o ƒë∆∞·ª£c thi·∫øt l·∫≠p.")
        
        # Quay l·∫°i menu qu·∫£n l√Ω link game
        handle_game_link_management(message)
    else:
        bot.reply_to(message, "‚ùå B·∫°n kh√¥ng c√≥ quy·ªÅn truy c·∫≠p ch·ª©c nƒÉng n√†y!")

@bot.message_handler(func=lambda message: message.text == "üîô Quay l·∫°i menu ch√≠nh")
def back_to_main_menu_from_admin(message):
    handle_start(message)

if __name__ == "__main__":
    # === Kh·ªüi ƒë·ªông scheduler ƒê·∫≠p H·ªôp ===
    def drop_scheduler_loop():
        global drop_thread_started
        if drop_thread_started:
            return
        drop_thread_started = True
        last_drop_key = None
        while True:
            try:
                conf = get_drop_settings()
                if not conf.get('enabled', True):
                    time.sleep(10)
                    continue
                # L·∫•y th·ªùi gian theo m√∫i gi·ªù ƒë√£ c√†i ƒë·∫∑t
                tz_name = conf.get('timezone', 'Asia/Ho_Chi_Minh')
                try:
                    tz = pytz.timezone(tz_name)
                    now = datetime.now(tz)
                except:
                    now = datetime.now()
                
                target_times = conf.get('times', ["09:00", "21:00"])
                now_time = now.strftime('%H:%M')
                # T·∫°o key ri√™ng cho m·ªói th·ªùi ƒëi·ªÉm trong ng√†y
                key = f"{now.strftime('%Y%m%d')}-{now_time}"
                # K√≠ch ho·∫°t ƒë√∫ng ph√∫t ƒë√£ ƒë·∫∑t (gi√¢y < 5)
                if now.second < 5 and now_time in target_times and key != last_drop_key:
                    log_debug(f"Triggering drop at {now_time}, key: {key}, last_key: {last_drop_key}")
                    # M·∫∑c ƒë·ªãnh: lu√¥n g·ª≠i cho t·∫•t c·∫£ user
                    send_to_all_users()
                    last_drop_key = key
                    log_debug(f"Drop sent successfully, new last_key: {last_drop_key}")
                # T·ª± t·∫Øt ƒë·ª£t khi h·∫øt th·ªùi gian
                if current_drop.get('active') and not is_drop_active():
                    end_current_drop()
                
                # T·ª± ƒë·ªông x√≥a ·∫£nh v√† n√∫t sau 5 ph√∫t
                auto_remove_drop_after_5min()
                
                time.sleep(1)
            except Exception as e:
                log_error(f"drop_scheduler_loop error: {e}")
                time.sleep(2)

    threading.Thread(target=drop_scheduler_loop, daemon=True).start()

    while True:
        try:
            bot.infinity_polling(timeout=60, long_polling_timeout=20, skip_pending=True)
        except Exception as e:
            log_error(f"L·ªói polling: {e}")
            if "Connection" in str(e) or "10054" in str(e):
                log_error("L·ªói k·∫øt n·ªëi m·∫°ng, ƒë·ª£i 30s r·ªìi th·ª≠ l·∫°i...")
                time.sleep(30)  # ƒê·ª£i l√¢u h∆°n cho l·ªói m·∫°ng
            else:
                time.sleep(5)  # ƒê·ª£i 5s cho l·ªói kh√°c

# === T·ª∞ ƒê·ªòNG R∆†I H·ªòP M·ªñI 60 PH√öT ===
def auto_drop_loop():
    while True:
        try:
            conf = get_drop_settings()
            if conf.get('enabled', True):
                chat_id = conf.get('target_chat_id')
                # M·∫∑c ƒë·ªãnh: lu√¥n g·ª≠i cho t·∫•t c·∫£ user
                send_to_all_users()
                log_debug('üí• ƒê·∫≠p h·ªôp t·ª± ƒë·ªông r∆°i th√†nh c√¥ng!')
            else:
                log_debug('üîï ƒê·∫≠p h·ªôp ƒëang b·ªã t·∫Øt.')
        except Exception as e:
            log_error(f'Auto drop error: {e}')
        time.sleep(3600)  # 60 ph√∫t

threading.Thread(target=auto_drop_loop, daemon=True).start()
